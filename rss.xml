<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>carlos schults / blog</title>
    <description>Artigos sobre desenvolvimento de software, banco de dados e vários assuntos ligados à tecnologia.</description>
    <link>http://carlosschults.net/</link>
    <atom:link href="http://carlosschults.net/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 02 May 2016 18:31:30 -0300</pubDate>
    <lastBuildDate>Mon, 02 May 2016 18:31:30 -0300</lastBuildDate>
    <generator>Jekyll v3.1.2</generator>
    
    
      <item>
        <title>Fases de Estabilização</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://res.cloudinary.com/dz5ppacuo/image/upload/v1462111255/balance-min_qkdhxx.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NOTA&lt;/strong&gt;: O artigo a seguir foi originalmente escrito por Robert C. Martin, mais conhecido como Uncle Bob. Bob é um programador com décadas de experiência, autor de diversos livros (Código Limpo, por exemplo) e foi o organizador do encontro em 2001 que deu origem ao &lt;a href=&quot;http://agilemanifesto.org/iso/ptbr/&quot;&gt;Manifesto Para Desenvolvimento Ágil de Software&lt;/a&gt;. Ele gentilmente me autorizou a fazer essa tradução. Caso lhe interesse, &lt;a href=&quot;http://blog.cleancoder.com/uncle-bob/2016/01/14/Stabilization.html&quot;&gt;clique aqui para ler o artigo original&lt;/a&gt;.
&lt;!--more--&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;Enquanto tomava meu café de manhã e dava uma olhada no facebook em meu celular, fui inundado com updates de status de proprietários de veículos Tesla que estavam animados porque seus carros agora poderiam entrar na garagem de maneira autônoma. Minha resposta a esses posts no facebook talvez tenha sido um pouco cínica; mas eu disse a todos eles:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Vai demorar muito até eu confiar em um software para dirigir o carro no qual eu estou.
Porque eu – &lt;strong&gt;sei&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Eu sei o quê? Eu sei o quão difícil é testar software para cada imprevisto. 
E eu sei como é fácil enganar a si próprio achando que você testou.&lt;/p&gt;

&lt;p&gt;E isso me fez pensar sobre como você deveria testar o software de um carro autônomo.&lt;/p&gt;

&lt;p&gt;E isso me fez pensar sobre como as pessoas de fato testam sistemas de software.&lt;/p&gt;

&lt;p&gt;E isso finalmente me fez pensar sobre fases de estabilização.&lt;/p&gt;

&lt;p&gt;Você sabe o que é uma fase de estabilização, não sabe? Uma fase de estabilização ocorre no final de uma release. Algum tempo é reservado para apenas deixar o sistema rodar. Por uma semana, ou um mês, todo mundo apenas assiste o sistema rodando. Eles o tratam como um bebê dormindo. Eles evitam barulhos altos, batidas de portas, e conversa alta. Eles andam nas pontas dos dedos, dando uma olhadinha de tempos em tempos, com a esperança de que ele não acorde e quebre.&lt;/p&gt;

&lt;p&gt;OK, talvez isso seja um pouco exagarado. – Talvez. Eu imagino que a maioria dos times que usam fases de estabilização realmente trabalham muito duro para estressar seus sistemas. Pelo menos eu espero que eles façam isso. Eles deveriam estar inserindo muitos dados no dados sob condições diversas; incluindo dados incorretos, e que causaram problemas no passado.&lt;/p&gt;

&lt;p&gt;Mas essa é a coisa importante sobre fases de estabilização:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Nós as usamos porque temos medo. 
Nós temos medo porque não temos certeza do que o sistema irá fazer.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Há uma certa dissonância cognitiva entre dizer que somos profissionais, e sermos tão incertos sobre o que criamos que temos medo do que pode fazer. Geralmente se espera que uma equipe de profissionais tenha um alto grau de confiança e certeza.&lt;/p&gt;

&lt;p&gt;Quanto maior o tempo de duração da fase de estabilização, menor é a certeza que o time tem sobre o sistema. As equipes que precisam de apenas um dia têm muito mais confiança em seus sistemas que as equipes que querem uma semana, ou um mês.&lt;/p&gt;

&lt;p&gt;A falha lógica aqui é que tempo de execução indica qualidade. Mas tempo na verdade não é relacionado à qualidade. Tempo simplesmente cria falsa confiança.&lt;/p&gt;

&lt;p&gt;O comportamento do sistema na fase de estabilização tem pouco ou nada a ver com o comportamento do sistema em produção; porque os dados entrando no sistema de produção são dados completamente novos. Os novos dados podem levar o sistema a percorrer caminhos que a fase de estabilização nunca executou.&lt;/p&gt;

&lt;p&gt;Então fases de estabilização apenas criam falsa confiança. Elas são uma estratégia para “tirar o seu da reta.” Quando o sistema falha em produção, você pode pelo menos dizer que você fez o esforço devido de rodar o sistema por um mês na fase de estabilização; dessa forma exonerando a equipe da culpa de deixar um defeito crítico entrar no sistema.&lt;/p&gt;

&lt;p&gt;O problema crucial é que a fase de estabilização existe porque o time de desenvolvimento produziu código no qual eles não confiam. Então eles rodam o sistema por um mês para criar suficiente falsa confiança para enfrentar a incerteza.&lt;/p&gt;

&lt;p&gt;O que a equipe realmente precisa fazer é atacar sua incerteza diretamente. Não rodando o sistema inutilmente por um mês; mas sim corrigindo os problemas no seu processo de desenvolvimento que criaram essa incerteza. Considere o checklist seguinte:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Você está executando ferramentas de cobertura? Você checa se cada if e while estão cobertos?&lt;/li&gt;
  &lt;li&gt;A cobertura de testes unitários é próxima de 100%?&lt;/li&gt;
  &lt;li&gt;Você precisa aumentar um pouco a cobertura escrevendo mais testes?&lt;/li&gt;
  &lt;li&gt;Você tem testes de aceitação automatizados escritos por (ou pelo menos validados por) pessoas de negócio e Garantia de Qualidade?&lt;/li&gt;
  &lt;li&gt;A cobertura de testes é alta o suficiente? Você precisa aumenta-la um pouco pedindo para a GQ considerar mais alguns casos extremos?&lt;/li&gt;
  &lt;li&gt;Você tem testes de integração automatizados escritos por arquitetos e desenvolvedores líderes?&lt;/li&gt;
  &lt;li&gt;Esses testes estressam os caminhos de comunicação entre os componentes?&lt;/li&gt;
  &lt;li&gt;Eles checam por casos excepctionais, problemas nos limites e timeouts?&lt;/li&gt;
  &lt;li&gt;Eles examinam o comportamento do sistema sob cargas variáveis?&lt;/li&gt;
  &lt;li&gt;Se você tem múltiplas threads, você tem uma estratégia para estressar essas threads durante seus testes unitários e testes de aceitação?&lt;/li&gt;
  &lt;li&gt;Por exemplo, você implementou ferramentas que introduzem delays aleatórios e cargas aleatórios para que as probabilidades de condições de corrida sejam aumentadas?&lt;/li&gt;
  &lt;li&gt;Melhor ainda, você está gradualmente eliminando a possbilidade de condições de corrida por meio da eliminação de estados mutáveis entre threads? Você desenhou todos os diagramas de sequência de mensagens e os examinou em busca de corridas em potencial?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Esse checklist é só um exemplo. Eu tenho certeza que você consegue pensar em mais coisas para acrescentar. O ponto é que é melhor ser proativo a respeito da sua incerteza, do que ser passivo a respeito dela. E fases de estabilização são passivas.&lt;/p&gt;

&lt;p&gt;O objetivo de equipes de software que estão atualmente usando fases de estabilização deveria ser aumentar sua confiança com o tempo, e dessa forma reduzir a duração de suas fases de estabilização. Reduza de um mês, para uma semana. Então de uma semana para um dia. Então de um dia para uma hora.&lt;/p&gt;

&lt;p&gt;E então, finalmente, aumenta sua confiança ao ponto de poder eliminar a fase de estabilização de uma vez por todas.&lt;/p&gt;

&lt;p&gt;Uma historinha:&lt;/p&gt;

&lt;p&gt;Eu recentemente fiz um test-drive com uma Tesla. É um carro divertido de se dirigir. Realmente divertido. 
Eu testei a funcionalidade de piloto automático, que é facilmente ativada apertando um botão na coluna de direção. 
O carro alegremente lhe informa que a partir de agora está dirigindo a si mesmo; e lhe alerta para manter as mãos no volante. Preste atenção nesse aviso!&lt;/p&gt;

&lt;p&gt;O carro se saiu razoavelmente bem quando as marcas na estrada eram visíveis, mas parecia bastante disposto a me arrebentar em algumas barragens de construção. Não é seguro tirar suas mãos do volante ou seus olhos da pista. Para mim, isso torna a funcionalidade menos que inútil.&lt;/p&gt;

&lt;p&gt;O vendedor estava sentado do meu lado. Em um certo momento nós estávamos indo a 70 km/h em direção à traseira de um carro parado no sinal fechado. O vendedor disse: “Confie no carro.” E eu pensei: “Até parece!” E &lt;strong&gt;eu&lt;/strong&gt; freei o carro. 
A tecnologia é interessante; mas perigosa. NUNCA “confie no carro”!&lt;/p&gt;

&lt;p&gt;Talvez você tenha percebido que a perspectiva de carros autônomos não me enche de entusiasmo. Eu vou continuar pensando o que será que esses carros farão um segundo após 29 de fevereiro.&lt;/p&gt;
</description>
        <pubDate>Mon, 02 May 2016 00:00:00 -0300</pubDate>
        <link>http://carlosschults.net/pt/traducao-fases-estabilizacao/</link>
        <guid isPermaLink="true">http://carlosschults.net/pt/traducao-fases-estabilizacao/</guid>
        
        <category>traduções</category>
        
        <category>metodologias ágeis</category>
        
        <category>integração contínua</category>
        
        <category>testes de software</category>
        
        <category>testes automatizados</category>
        
        
      </item>
    
      <item>
        <title>Testes unitários para iniciantes - Parte 1</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://res.cloudinary.com/dz5ppacuo/image/upload/v1459979937/testes-unitarios-iniciantes-min_povcse.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Você já deve ter trabalhado em um sistema assim: incrivelmente complexo, com uma base de código gigantesca, mal documentada, cheia de gambiarras, acoplamentos desnecessários, com arquitetura confusa, especificações inexistentes, onde era quase considerado um milagre que o software chegasse a funcionar. Talvez eu tenha acabado de descrever seu projeto atual!
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;Nesse tipo de projeto, é comum que os desenvolvedores fiquem com receio de mexer no código, pois sabem que, inevitavelmente, algo vai quebrar. E provavelmente, o erro só vai ser descoberto em produção.&lt;/p&gt;

&lt;p&gt;Agora, imagine se a aplicação fosse completamente protegida por um sistema de alarmes. Cada vez que uma &lt;em&gt;feature&lt;/em&gt; parasse de funcionar, o alarme dispararia. Os desenvolvedores seriam imediatamente notificados, e alguém resolveria o problema o mais rápido possível.&lt;/p&gt;

&lt;p&gt;Imagine ainda que esse sistema de alarmes fosse composto por centenas de sistemas menores. Cada um desses subsistemas seria responsável por “vigiar” uma parte bem pequena e específica da sua aplicação. E para que o sistema de alarmes funcionasse bem, os subsistemas deveriam ser totalmente independentes uns dos outros.&lt;/p&gt;

&lt;p&gt;A adoção de um sistema desse tipo traria muitos benefícios. Logo de cara, o medo de mexer no código iria embora. A refatoração se tornaria mais fácil e frequente, e, como consequência, a qualidade do código aumentaria.&lt;/p&gt;

&lt;p&gt;O próprio processo de desenvolvimento seria simplificado. O sistema de alarmes reduziria drasticamente a necessidade dos lentos testes manuais, agilizando a entrega da aplicação para os usuários.&lt;/p&gt;

&lt;p&gt;Por fim, a necessidade de independência entre os subsistemas incentivaria a diminuição do acoplamento entre as partes da aplicação.&lt;/p&gt;

&lt;p&gt;Parece bom demais para ser verdade? Pois saiba que não é. Esse sistema de alarmes é o benefício que você ganha ao implementar uma &lt;strong&gt;suíte de testes unitários&lt;/strong&gt; em sua aplicação.&lt;/p&gt;

&lt;h2 id=&quot;o-que-so-testes-unitrios&quot;&gt;O que são testes unitários&lt;/h2&gt;

&lt;p&gt;Vamos ver a definição da Wikipédia:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;In computer programming, unit testing is a software testing method by which individual units of source code, […] are tested to determine whether they are fit for use. Intuitively, one can view a unit as the smallest testable part of an application.  […]
 Unit tests are typically written and run by software developers to ensure that code meets its design and behaves as intended.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Em tradução livre:
&amp;gt; Em programação de computadores, teste unitário é um método de teste de software pelo qual unidades individuais de código fonte […] são testadas para determinar se são adequadas para o uso. Intuitivamente, pode-se considerar uma unidade como a menor parte testável de uma aplicação. […]
 Testes unitários são tipicamente escritos e executados por desenvolvedores para garantir que o código está de acordo com o projeto e se comporta da maneira desejada.&lt;/p&gt;

&lt;p&gt;A primeira coisa que chama a atenção é que os testes unitários &lt;strong&gt;não têm o propósito de testar o sistema como um todo&lt;/strong&gt;. Pelo contrário, eles testam pequenas partes do software - as tais das unidades. E o que é uma unidade? Existem diversos pontos de vista conflitantes sobre isso, diversas “escolas de pensamento”. Mas é seguro dizer que, no contexto de programação orientada a objeto, a maioria das pessoas considera unidade como sendo uma &lt;strong&gt;classe&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Logo a seguir, nós vemos que os testes unitários são tipicamente escritos e executados por programadores. Isso é interessante por dois motivos: primeiro, contradiz uma ideia antiga de que programadores não são bons testadores de software (vou voltar nesse ponto depois). E mais importante do que isso, ele deixa claro a principal característica dos testes unitários: eles são &lt;strong&gt;automatizados&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Tenha em mente que existem diversos tipos de testes automatizados, mas aqui estamos tratando apenas de testes unitários (os quais, de acordo com diversos autores, tais como &lt;a href=&quot;http://martinfowler.com/bliki/TestPyramid.html&quot;&gt;Martin Fowler&lt;/a&gt;, são os que trazem mais benefícios para uma aplicação).&lt;/p&gt;

&lt;p&gt;Na prática, os testes unitários consistem de classes contendo métodos que testam partes pequenas e isoladas do sistema. Essas classes são criadas com o auxílio de um framework de testes (como o JUnit no Java, ou o NUnit ou o Microsoft Test no .Net). Esses testes podem então ser executados pela linha de comando, pela sua IDE ou mesmo por um serviço de build automatizado.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://res.cloudinary.com/dz5ppacuo/image/upload/v1460211309/teste00_bnsbfl.png&quot; alt=&quot;Exemplo de método de teste em C#&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Após a execução dos testes, você obtém um retorno imediato sobre quais testes passaram e quais falharam, acompanhado do tempo de execução de cada um dos testes.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://res.cloudinary.com/dz5ppacuo/image/upload/v1459979476/teste01_ciglca.png&quot; alt=&quot;Janela exibindo resultados da execução de testes unitários&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Com base nesse feedback, você decide o melhor curso de ação. Idealmente, um teste que falha deveria ser sinal de erro no código. O código de produção deveria então ser ajustado para que o teste volte a passar.&lt;/p&gt;

&lt;h2 id=&quot;benefcios-dos-testes-unitrios&quot;&gt;Benefícios dos testes unitários&lt;/h2&gt;

&lt;p&gt;No começo do post, ao usar a metáfora do sistema de alarmes, eu falei de alguns dos benefícios que os testes unitários trazem, como por exemplo:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;incentivo à refatoração;&lt;/li&gt;
  &lt;li&gt;incentivo à evolução da arquitetura do sistema;&lt;/li&gt;
  &lt;li&gt;simplificação e agilidade na entrega do produto aos usuários;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Outro benefício que vale a pena citar é que os testes também servem como &lt;strong&gt;documentação do código&lt;/strong&gt;. Pense bem: para cada classe de produção no seu sistema, existem diversos métodos de teste que exercitam e exemplificam todos os usos possíveis dessa classe. Uma boa suíte de testes poderia ajudar um recém-chegado ao time adquirir familiaridade com a base de código em pouco tempo.&lt;/p&gt;

&lt;p&gt;Ou seja: documentação viva, executável, sempre atualizada, e que nunca mente.&lt;/p&gt;

&lt;p&gt;Não podemos deixar de mencionar também que uma boa suíte de testes unitários também ajuda a prevenir a regressão de bugs. É uma ótima prática criar um novo teste toda vez que um bug for encontrado. Assim, caso alguma alteração futura faça com que o bug retorne (“regresse”), o teste vai indicar isso.&lt;/p&gt;

&lt;p&gt;Finalmente, um dos maiores benefícios da automação de testes que eu não vejo sendo alardeado por aí é a redução de custos - talvez por ser um fator mais de negócios do que técnico. Digamos que antes de cada release a sua equipe faça um teste completo na aplicação, com quatro testadores, trabalhando 8 horas por dia, durante duas semanas. Basta fazer uma simples multiplicação e você verá que &lt;strong&gt;testes manuais custam caro.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Pior ainda: eles custam caro duas vezes. Primeiro, há o custo dos testes em si, que você pode calcular com a fórmula &lt;em&gt;valor da hora de trabalho dos testadores x nº de testadores x horas gastas em teste.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Além disso, há o &lt;a href=&quot;https://pt.wikipedia.org/wiki/Custo_de_oportunidade&quot;&gt;custo de oportunidade&lt;/a&gt;: quando profissionais precisam desempenhar testes manuais que poderiam ser automatizados, eles estão deixando de desempenhar atividades criativas/intelectuais que teriam potencial de trazer ganhos muito maiores para a empresa.&lt;/p&gt;

&lt;h2 id=&quot;equvocos-comuns&quot;&gt;Equívocos comuns&lt;/h2&gt;

&lt;p&gt;Nessa seção, vou tentar esclarecer alguns dos mitos e equívocos que existem a respeito de testes unitários.&lt;/p&gt;

&lt;h3 id=&quot;programadores-no-deveriam-escrever-testes-pois-geralmente-so-maus-testadores&quot;&gt;Programadores não deveriam escrever testes, pois geralmente são maus testadores&lt;/h3&gt;

&lt;p&gt;Existe uma ideia bastante difundida de que programadores não deveriam testar seu próprio código. O raciocínio é que eles, inconscientemente, evitariam usar a aplicação de uma maneira que a faria quebrar. E por experiência própria, eu digo que isso de fato acontece. Já perdi a conta de quantas vezes algum colega encontrou bugs em uma aplicação que eu fiz após &lt;strong&gt;segundos&lt;/strong&gt; de uso, sendo que eu já havia passado muito mais tempo que isso testando e sem conseguir fazer falhar.&lt;/p&gt;

&lt;p&gt;O ponto a salientar aqui é: &lt;strong&gt;há testes e testes&lt;/strong&gt;. Geralmente, quando pessoas dizem que programadores não deveriam testar, elas estão se referindo a testes de sistema, também chamados testes ponta a ponta. Tais testes têm o propósito de testar o sistema como um todo, o que, como já vimos, não é o objetivo dos testes unitários.&lt;/p&gt;

&lt;p&gt;Muitas vezes o que ocorre é simplesmente falta de informação: a pessoa talvez desconheça a natureza e propósito dos testes unitários, e os toma por testes de ponta a ponta.&lt;/p&gt;

&lt;h3 id=&quot;escrever-testes-unitrios--uma-perda-de-tempo--o-mesmo-que-programar-duas-vezes&quot;&gt;Escrever testes unitários é uma perda de tempo; é o mesmo que programar duas vezes&lt;/h3&gt;

&lt;p&gt;Ao tentar “vender” testes unitários para a gerência na sua empresa, uma boa estratégia é apelar para a redução de custos, como visto anteriormente. Mas…e os desenvolvedores? Como convencê-los a gastar mais tempo escrevendo código de teste além do código de produção?&lt;/p&gt;

&lt;p&gt;Dizer que os testes unitários são perda de tempo é uma justificativa comum apresentada por desenvolvedores que não querem escrever testes. E é uma justificativa aparentemente legítima. Afinal, nossos prazos são apertadíssimos, como podemos arrumar tempo para ficar escrevendo casos de teste?&lt;/p&gt;

&lt;p&gt;O que essas pessoas falham em perceber é que &lt;em&gt;elas já testam o próprio código constantemente, mesmo que não chamem por esse nome.&lt;/em&gt; É bem provável que seu workflow de desenvolvimento seja bem parecido com isso:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Escreve um pouco de código&lt;/li&gt;
  &lt;li&gt;Compila&lt;/li&gt;
  &lt;li&gt;Executa a aplicação, testa a funcionalidade
    &lt;ul&gt;
      &lt;li&gt;Se funcionou, começa a escrever a próxima funcionalidade&lt;/li&gt;
      &lt;li&gt;Se não funcionou, passa um tempo debugando até encontrar e corrigir o erro&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Repita&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;O que estamos propondo é simplesmente trocar o ciclo “escreve código de produção -&amp;gt; compila -&amp;gt; testa -&amp;gt; debuga -&amp;gt; repete” pelo ciclo “escreve código de produção -&amp;gt; escreve código de testes -&amp;gt; executa testes -&amp;gt; corrige código de produção se necessário”.&lt;/p&gt;

&lt;p&gt;É até possível argumentar que os ciclos são praticamente os mesmos. Mas a grande vantagem dos testes unitários é que, uma vez escritos, eles estão automatizados para o resto da vida do projeto. Você “perde tempo” só uma vez. Você investe tempo e esforço no começo, para criar os testes, e colhe os benefícios por tempo indefinido.&lt;/p&gt;

&lt;h3 id=&quot;testes-unitrios-substituem-todos-os-testes-manuais&quot;&gt;Testes unitários substituem todos os testes manuais&lt;/h3&gt;

&lt;p&gt;Testes unitários não são os únicos tipos de testes que trazem benefícios a um projeto. Também podemos utilizar outros tipos de testes automatizados como &lt;strong&gt;testes de integração&lt;/strong&gt; e &lt;strong&gt;testes de aceitação&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://res.cloudinary.com/dz5ppacuo/image/upload/v1460217453/testing_triangle-300x233_nzq8kx.jpg&quot; alt=&quot;Triângulo dos testes, mostrando a razão ideal entre os diversos tipos de teste de software&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Isso não significa que testes manuais devem ser extintos. Pelo contrário, eles continuam tendo um papel importante no processo de controle de qualidade. De preferência, os testes manuais devem se concentrar nas áreas que não podem ser automatizadas, como testes de usabilidade.&lt;/p&gt;

&lt;p&gt;Dentro de um contexto de metodologias ágeis, é essencial que o Product Owner/Cliente/Pessoa de Negócios valide e aceite as histórias antes delas serem incluídas em uma release.&lt;/p&gt;

&lt;p&gt;Testes manuais exploratórios, que não seguem um roteiro definido, costumam ser valiosos na detecção de certos tipos de bugs. Os casos de testes automatizados tendem a focar no “Happy Path”, ou seja, o cenário no qual deu tudo certo, as unidades foram usadas exatamente do jeito que o codificador pensou e projetou. Na vida real, é muito comum que os usuários utilizem a aplicação de maneiras…como dizer?…“criativas”. Então,colocar o software sob stress, utilizando-o de maneiras diferentes e inesperadas, podem acabar revelando bugs que de outra forma permaneceriam ocultos.&lt;/p&gt;

&lt;p&gt;É claro que, uma vez que o bug tenha sido revelado pelo teste manual, deve-se imediatamente escrever um teste automatizado que o exponha. Assim, na eventualidade do bug regredir, ele será facilmente detectado.&lt;/p&gt;

&lt;h2 id=&quot;concluso&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Testes unitários - e automação de testes, no geral - são um tema gigantesco. Há muitos livros sobre esse tema, bem como teses de mestrado. Há conferências anuais em diversos países apenas sobre teste de software. Então, é claro que seria impossível que eu, com uma mera postagem no meu blog, fizesse jus a esse tema.&lt;/p&gt;

&lt;p&gt;Mas eu espero, sinceramente, ter feito uma boa introdução aos testes unitários e esclarecido um pouco das dúvidas que os iniciantes geralmente têm. Qualquer dúvida, sugestão ou crítica, a área de comentário é de vocês.&lt;/p&gt;

&lt;p&gt;Este post é o início de uma série dedicada ao tema dos testes.
No próximo artigo, começaremos a colocar a mão na massa: vou mostrar a vocês como criar seus primeiros testes!&lt;/p&gt;

&lt;p&gt;Até lá!&lt;/p&gt;
</description>
        <pubDate>Sat, 09 Apr 2016 00:00:00 -0300</pubDate>
        <link>http://carlosschults.net/pt/testes-unitarios-iniciantes-parte1</link>
        <guid isPermaLink="true">http://carlosschults.net/pt/testes-unitarios-iniciantes-parte1</guid>
        
        <category>testes de software</category>
        
        <category>testes unitários</category>
        
        <category>metodologias ágeis</category>
        
        <category>testes automatizados</category>
        
        
      </item>
    
      <item>
        <title>Programar em português ou inglês? That&#39;s the question!</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://res.cloudinary.com/dz5ppacuo/image/upload/v1458429920/portugues-ou-ingles-1038x437_izhi3i.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;No contexto de boas práticas de desenvolvimento, um ponto que gera controvérsia é a escolha do idioma no qual codificar. Uma rápida busca no Google por “programar em português ou inglês” retorna 535 mil resultados, o que mostra que o tema realmente causa bastante discussão. 
&lt;!--more--&gt;
Recentemente conversei com um colega de trabalho e também com meu chefe a respeito desse assunto. Esse post é consequência dessas conversas e das pesquisas que fiz depois.&lt;/p&gt;

&lt;p&gt;Parece ser uma visão bastante comum na nossa área que programar em inglês é a melhor opção. Fabio Akita, grande referência na comunidade Ruby On Rails do Brasil, &lt;a href=&quot;http://www.akitaonrails.com/2013/03/24/quais-sao-algumas-das-piores-praticas-para-aplicacoes-ruby-on-rails--2&quot;&gt;inclui codificar em português - ou melhor dizendo, qualquer idioma que não o inglês - na sua lista de piores práticas de desenvolvimento&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Escreva nomes em inglês dentro do seu código. Não me importo se você é brasileiro, italiano, francês ou o que   for. Nomes de classes, de variáveis, de métodos, tudo deve ser em inglês. Estamos num mundo globalizado, não é pensar muito longe que amanhã um americano vai mexer no seu código todo em português. Além do problema de consistência: a sintaxe da linguagem, todas as bibliotecas padrão, é tudo em inglês. É uma enorme dissonância cognitiva ter nomes em português no meio. É como você estar lendo uma revista em português com diversos parágrafos em inglês no meio. Não faz nenhum sentido.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Carlos Brando, outro nome conhecido no mundo Rails, &lt;a href=&quot;http://nomedojogo.com/2009/02/13/rails-way-3-nomes-de-metodos-e-variaveis-devem-ser-obvios/&quot;&gt;deu opinião semelhante em um post de 2009&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Embora não exista uma regra escrita para isto, também sou contra nomear variáveis, métodos ou classe em português. Acho que como todo o código já está em inglês, graças as palavras chaves do Ruby, devemos manter absolutamente tudo em inglês também. Isto não é tão difícil assim, já que você pode fazer uso de tradutores e dicionários (online) para encontrar a melhor descrição para eles.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Um exemplo de como esse tema é inflamável: &lt;a href=&quot;http://blog.stackoverflow.com/2014/01/ola-mundo-announcing-stack-overflow-in-portuguese/&quot;&gt;há cerca de dois anos foi lançada a versão em português do Stack Overflow&lt;/a&gt;, famoso site de perguntas e respostas pra programadores. Pare aqui e vá lá dar uma olhada no post. Viu a quantidade de comentários criticando a iniciativa? A controvérsia foi tanta que duas semanas depois a equipe do Stack Overflow publicou um novo post, dessa vez em inglês, justificando a decisão.&lt;/p&gt;

&lt;p&gt;Eu acredito que a discussão é necessária e saudável e que existem bons argumentos nos dois lados. Assim, vou  examinar opiniões a favor do uso de cada idioma, e ao final do post, expressar minha conclusão.&lt;/p&gt;

&lt;h2 id=&quot;argumentos-a-favor-do-ingls&quot;&gt;Argumentos a favor do inglês&lt;/h2&gt;

&lt;p&gt;Um dos argumentos mais comuns usados a favor do inglês é que seria estranho ou feio misturar dois idiomas na codificação. Como as palavras reservadas das linguagens de programação/frameworks/SGBD’s já são em inglês, utilizar a língua portuguesa para nomear variáveis e outras coisas acaba gerando híbridos como &lt;em&gt;getNome&lt;/em&gt;, &lt;em&gt;ProdutosController&lt;/em&gt;, &lt;em&gt;clientes.ForEach&lt;/em&gt;, &lt;em&gt;CodigoNaoEncontradoException&lt;/em&gt; e assim por diante. No trecho citado logo ali acima, Fabio Akita afirma que a mistura dos idiomas causa uma dissonância cognitiva, seria como ler uma página escrita em um idioma e de repente se deparar com parágrafos escrito em outro.&lt;/p&gt;

&lt;p&gt;Outro argumento comum, também utilizado pelo Akita no trecho citado, é a possibilidade de um programador não-brasileiro vir a trabalhar no projeto. Imagine um projeto que conte com desenvolvedores da França, Alemanha, Brasil, Estados Unidos. Se cada um resolve programar no seu idioma, a comunicação se tornará impossível, a menos que todos os membros da equipe sejam proficientes nos idiomas de todos os outros membros, o que seria bastante improvável.&lt;/p&gt;

&lt;p&gt;Um ponto bem parecido com o anterior é que a utilização do português prejudicaria uma eventual venda do produto para uma empresa de outro país, o que é de fato inegável.&lt;/p&gt;

&lt;p&gt;O fato de que o inglês é a língua franca da tecnologia também figura constantemente entre os argumentos dos defensores do uso dessa língua na codificação. Segundo eles, qualquer desenvolvedor que se preze &lt;strong&gt;precisa&lt;/strong&gt; ter um domínio avançado da língua inglesa. Sendo assim, o uso da inglês na verdade facilitaria o desenvolvimento, e não o contrário.&lt;/p&gt;

&lt;p&gt;Outro ponto interessante a favor do inglês é que os identificadores nesse idioma tendem a ser menores, o que incentiva a um código mais limpo e conciso. Por exemplo, compare &lt;em&gt;setName&lt;/em&gt; com &lt;em&gt;atribuirNome&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Uma consequência do ponto anterior é que o uso de um único idioma ajuda a consolidar um vocabulário compartilhado entre todos os programadores. &lt;em&gt;Get&lt;/em&gt; e &lt;em&gt;Set&lt;/em&gt;, por exemplo, são palavras-chaves familiares para a maioria dos desenvolvedores, por serem extremamente comuns em API’s e bibliotecas diversas. Digamos que um programador recém-chegado à sua empresa recebe a tarefa de dar manutenção em uma biblioteca que vocês desenvolveram para trabalhar com XML. Ele provavelmente teria mais facilidade em encontrar um método chamado &lt;em&gt;GetChildren()&lt;/em&gt; do que se fosse chamado ObterFilhos().&lt;/p&gt;

&lt;p&gt;Outra vantagem da utilização do inglês seria…que ela melhora o seu conhecimento de inglês. Já que programadores precisam dominar esse idioma de qualquer forma, toda e qualquer oportunidade de praticá-lo é válida.&lt;/p&gt;

&lt;h2 id=&quot;argumentos-a-favor-do-portugus&quot;&gt;Argumentos a favor do português&lt;/h2&gt;

&lt;p&gt;Um argumento a favor do uso do português é a baixa proficiência em inglês apresentada pelos desenvolvedores brasileiros em geral, e como isso pode prejudicar a comunicação não apenas entre os desenvolvedores, mais também entre os desenvolvedores e as pessoas de negócio:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Da mesma forma, uma regra de negócio traduzida para o inglês pode ser mal traduzida por quem não domina o idioma. Falsos cognatos existem e podem ser utilizados nessa tradução cotidiana. Imagine que, ao invés de criar classes chamadas Funcionario e Empregador você crie classes chamadas Employee e Employer. Isso seria tão confuso para um desenvolvedor que não domina o inglês, quanto para um desenvolvedor que domina o inglês. Na hora de programar, os termos podem misturar-se.
&lt;a href=&quot;http://www.ventron.com.br/programar-em-portugues-ou-ingles/&quot;&gt;Gustavo Gondim&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Eu já vi tantas atrocidades na transliteração de português para inglês usando Google Translator… Na falta da compreensão, pega-se a primeira palavra que aparece. Ou cria-se expressões com termos em inglês usando a sintaxe do português. Confunde-se a forma de usar substantivos, verbos e adjetivos. A língua resultante pode ser inglês de índio, mas não é inglês. O ponto é que em uma equipe que não fala inglês nativamente, usar os termos de negócio em inglês pode complicar até o entendimento entre os programadores.[…]
&lt;a href=&quot;https://blogdofernandocorreia.wordpress.com/2011/09/21/que-lingua-usar-para-nomes-do-dominio-de-negocio/&quot;&gt;Fernando Correia&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Resumindo: uma equipe que tem domínio superficial do inglês necessariamente produz inglês de baixa qualidade, por não estar ciente das “pegadinhas” que o idioma pode apresentar (por exemplo: falsos cognatos). Mas ainda tem mais: é de conhecimento geral que programadores passam mais tempo lendo código do que escrevendo. E qualquer programador com alguma experiência vai concordar que ler código é bem mais difícil do que escrever. Ao forçar uma equipe sem desenvoltura na língua inglesa a trabalhar com uma base de código escrita nessa língua, estaríamos aumentando a barreira necessária para a compreensão do código, dificultando a manutenção e aumentando a chance de criação de bugs.&lt;/p&gt;

&lt;p&gt;O &lt;a href=&quot;http://programandosemcafeina.blogspot.com.br/2009/03/nomes-de-metodos-e-variaveis-devem-ser.html&quot;&gt;Tiago Albineli Motta, do blog “Programando Sem Cafeína”&lt;/a&gt;, traz um argumento bem interessante: de que o uso de idiomas diferentes prejudica a comunicação entre cliente e a equipe de desenvolvimento, principalmente quando o domínio do negócio é bastante específico. Para justificar, ele cita o exemplo de quando trabalhava em uma empresa que estava desenvolvimento um sistema para um laboratório geológico. Como os funcionários do laboratório usavam termos em português e a equipe de desenvolvimento em inglês, havia ruídos na comunicação.&lt;/p&gt;

&lt;p&gt;Destaco um trecho interessante abaixo (destaque meu):&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Eis então a pergunta: Será que um código que mistura termos em inglês e português causa mais problemas que os ruídos na comunicação com o cliente? Pode-se alegar que o código nem será mostrado ao usuário, &lt;strong&gt;mas na hora em que o desenvolvedor precisa se comunicar com o cliente, na mente dele ele não está trabalhando com amostras, ele está trabalhando com samples.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ainda no tema do domínio, poderíamos imaginar o desenvolvimento de uma aplicação que se integra com a famigerada Nota Fiscal Eletrônica. Como o xml da nota já vem com os campos todos em português, utilizar nomes de variáveis em inglês poderia adicionar um esforço cognitivo desnecessário.&lt;/p&gt;

&lt;h2 id=&quot;e-a-minha-opinio&quot;&gt;E a minha opinião?&lt;/h2&gt;

&lt;p&gt;Acredito ter sido capaz de demonstrar que existem boas opiniões nos dois lados desse debate. Mas e aí? Vocês devem estar se perguntando qual a minha opinião, não é? Ok, não vou ficar em cima do muro. Mas antes, acho necessário fazer algumas considerações importantes.&lt;/p&gt;

&lt;h3 id=&quot;o-ingls--a-lngua-franca-da-tecnologia&quot;&gt;O inglês é a língua franca da tecnologia&lt;/h3&gt;

&lt;p&gt;O inglês é a língua franca da tecnologia. E da ciência, das finanças, e de muitas outras coisas. Todo mundo tem o direito de gostar ou não do idioma que quiser, mas é simplesmente contra produtivo querer brigar com um fato da vida que não vai mudar tão cedo. Eu particularmente acho que deveríamos ser gratos que o “idioma obrigatório” é o inglês, e não o russo, árabe, ou mandarim, por exemplo.&lt;/p&gt;

&lt;p&gt;Então, independente do seu posicionamento no debate, aprender inglês é um investimento que vale muito a pena. O que nos leva ao próximo ponto.&lt;/p&gt;

&lt;h3 id=&quot;e-no--to-difcil-de-se-aprender-quanto-parece&quot;&gt;E não é tão difícil de se aprender quanto parece&lt;/h3&gt;

&lt;p&gt;Estou convencido de que uma enorme inteligência não é requisito para aprender inglês. Muito menos pagar cursos caros em escolas renomadas, ou fazer intercâmbio. Então por que há tantas pessoas que querem aprender inglês e &lt;a href=&quot;http://exame.abril.com.br/brasil/noticias/fluencia-do-brasileiro-no-ingles-so-piora-veja-ranking&quot;&gt;tão poucas conseguem&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;Em minha opinião, o primeiro motivo é que a maioria dessas pessoas não &lt;em&gt;querem&lt;/em&gt; realmente. E o segundo…é simplesmente que elas estudam errado, colocando o foco, tempo e energia no lugar onde não deviam.&lt;/p&gt;

&lt;p&gt;Em breve vou fazer um post totalmente dedicado ao tema do aprendizado de inglês, onde vou expandir e explicar melhor o parágrafo anterior.&lt;/p&gt;

&lt;h3 id=&quot;seu-projeto-tem-caractersticas-nicas-que-no-devem-ser-ignoradas&quot;&gt;Seu projeto tem características únicas que não devem ser ignoradas&lt;/h3&gt;

&lt;p&gt;Seu projeto atual provavelmente tem características únicas, que nem eu, nem o Fabio Akita, nem o Tiago Motta, ou qualquer outra pessoa de fora sabe. Não conhecemos o nível de fluência no inglês da sua equipe, nem o domínio da sua aplicação.&lt;/p&gt;

&lt;p&gt;Também desconhecemos o escopo do seu projeto, se todos os colaboradores são brasileiros ou se há pessoas de outros países,os prospectos de venda da empresa para uma companhia multinacional, etc.&lt;/p&gt;

&lt;p&gt;Ou seja: há uma série de fatores que podem e devem ser levadas em conta no momento de se adotar essa ou aquela prática, essa ou aquela metodologia. Nessas horas, você tem que exercitar o senso crítico: mantenha a mente aberta na hora de ler, pesquisar e conhecer opiniões contrárias, mas use seu bom senso e experiência para filtrar o e decidir o que encaixa com a cultura da sua empresa, equipe e projeto.&lt;/p&gt;

&lt;h3 id=&quot;tentar-prever-o-futuro--anti-gil&quot;&gt;Tentar prever o futuro é anti-ágil.&lt;/h3&gt;

&lt;p&gt;Eu costumo chamar isso de síndrome do “vai que um dia”, pois a conversa geralmente começa assim:&lt;/p&gt;

&lt;p&gt;“Vai que um dia o cliente precisa de [insira aqui funcionalidade que o cliente não precisa agora e provavelmente nunca vai precisar]? Vamos fazer!”&lt;/p&gt;

&lt;p&gt;E aí já viu: tabelas inúteis são criadas no banco de dados, classes e mais classes e formulários e telas e muito mais lixo entupindo seu projeto.&lt;/p&gt;

&lt;p&gt;Tentar prever toda e qualquer alteração no projeto é anti-ágil. Equipes ágeis dão pequenos passos, implementando as histórias priorizadas pelo cliente e nada mais. Quando os requisitos mudarem (e vão mudar) nós mudamos junto com eles.&lt;/p&gt;

&lt;p&gt;Entendeu onde eu quero chegar? “Vai que um dia uma empresa internacional resolve comprar nosso sistema? Vamos fazer todo o código e as tabelas em inglês!”&lt;/p&gt;

&lt;h3 id=&quot;em-resumo-bom-senso--a-chave&quot;&gt;Em resumo: bom-senso é a chave&lt;/h3&gt;

&lt;p&gt;Com base em tudo isso aí que você leu, minha opinião atualmente está assim: tentar utilizar o inglês sempre, &lt;strong&gt;exceto quando há ótimas razões para não utilizá-lo.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Projetos open-source? Tudo em inglês, &lt;em&gt;exceto em casos onde há benefícios claros em usar o português&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Em projetos particulares: se a equipe é fraca no inglês &lt;strong&gt;E/OU&lt;/strong&gt; o domínio é muito específico e tem termos e jargões de difícil tradução &lt;strong&gt;E/OU&lt;/strong&gt; há riscos claros de prejuízo na comunicação com o cliente, o português provavelmente é a melhor escolha.&lt;/p&gt;

&lt;p&gt;Se a situação é o contrário do descrito acima, inglês sem dúvida.&lt;/p&gt;

&lt;p&gt;Se desde o começo do projeto existe a certeza que a aplicação será disponibilizada para vários países, vocês vão precisar trabalhar em internacionalização, de tudo: especificações, ajuda, interface gráfica. Nesse caso, também não há motivo para não codificar em inglês.&lt;/p&gt;

&lt;h2 id=&quot;e-voc-o-que-acha&quot;&gt;E você, o que acha?&lt;/h2&gt;

&lt;p&gt;Concorda, discorda, prefere não opinar? Deixe um comentário aí em baixo e vamos continuando a conversa!&lt;/p&gt;

&lt;h2 id=&quot;referncias&quot;&gt;Referências&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://pt.stackoverflow.com/questions/301/devo-escrever-meu-programa-em-ingl%C3%AAs-ou-portugu%C3%AAs&quot;&gt;http://pt.stackoverflow.com/questions/301/devo-escrever-meu-programa-em-ingl%C3%AAs-ou-portugu%C3%AAs&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://programandosemcafeina.blogspot.com.br/2009/03/nomes-de-metodos-e-variaveis-devem-ser.html&quot;&gt;http://programandosemcafeina.blogspot.com.br/2009/03/nomes-de-metodos-e-variaveis-devem-ser.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://nsigustavo.blogspot.com.br/2009/09/que-idioma-devemos-utilizar-em-nosso.html&quot;&gt;http://nsigustavo.blogspot.com.br/2009/09/que-idioma-devemos-utilizar-em-nosso.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blogdofernandocorreia.wordpress.com/2011/09/21/que-lingua-usar-para-nomes-do-dominio-de-negocio/&quot;&gt;https://blogdofernandocorreia.wordpress.com/2011/09/21/que-lingua-usar-para-nomes-do-dominio-de-negocio/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.dev.mayogax.com/2014/02/a-polemica-questao-do-stack-overflow-em-portugues/&quot;&gt;http://www.dev.mayogax.com/2014/02/a-polemica-questao-do-stack-overflow-em-portugues/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://nomedojogo.com/2009/02/13/rails-way-3-nomes-de-metodos-e-variaveis-devem-ser-obvios/&quot;&gt;http://nomedojogo.com/2009/02/13/rails-way-3-nomes-de-metodos-e-variaveis-devem-ser-obvios/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ventron.com.br/programar-em-portugues-ou-ingles/&quot;&gt;http://www.ventron.com.br/programar-em-portugues-ou-ingles/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 29 Mar 2016 00:00:00 -0300</pubDate>
        <link>http://carlosschults.net/pt/programar-portugues-ou-ingles/</link>
        <guid isPermaLink="true">http://carlosschults.net/pt/programar-portugues-ou-ingles/</guid>
        
        <category>boas práticas</category>
        
        <category>inglês</category>
        
        
      </item>
    
      <item>
        <title>Resenha de Livro: O Programador Pragmático</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://res.cloudinary.com/dz5ppacuo/image/upload/v1457998345/the-pragmatic-programmer-review-min_tulprt.png&quot; alt=&quot;&quot; /&gt;
Se eu tivesse que escolher apenas um livro como leitura obrigatória de todo programador, eu escolheria “O Programador Pragmático”. Sem hesitar um segundo. Esse livro é simplesmente muito bom.
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;O Programador Pragmático: De Aprendiz a Mestre&lt;/em&gt;&lt;/strong&gt; é um livro de engenharia de software de autoria de Andrew Hunt e David Thomas, publicado originalmente em Outubro de  1999. O livro é organizado em capítulos curtos e auto-contidos, que podem ser lidos em qualquer ordem. Cada capítulo apresenta dicas (há 70 no total) que oferecem conselhos em diversos tópicos, tais como, estimativas, testes, &lt;em&gt;debugging&lt;/em&gt;, como prototipar, como se comunicar de maneira eficaz, boas práticas no uso de exceções, e muito mais.&lt;/p&gt;

&lt;p&gt;Cada capítulo também tem excercícios e/ou desafios. Qual a diferneça? Todos os excercícios têm respostas, e você pode encontrá-las no apêndice ao final do livro. Os desafios, por outro lado, não possuem necessariamente uma resposta certa. Eles foram feitos de maneira a te fazer pensar, refletir e (adivinha!) desafiar a  si próprio e ao jeito que você está acostumado a fazer as coisas.&lt;/p&gt;

&lt;p&gt;Uma coisa que eu gosto muito nesse livro é que ele é muito prático. É claro que a teoria tem o seu valor e seu lugar, e eu pessoalmente acredito que muitos programadores têm lacunas em seu conhecimento dos fundamentos da Ciência da Computação, e isso acaba prejudicando a nossa área. Dito isso, eu acho incrível que dois programadores tomaram o tempo de traduzir os seus anos de experiência e conhecimento em um livro que vai direto ao ponto com conselhos muito práticos que você consegue colocar em uso imediatamente.&lt;/p&gt;

&lt;p&gt;Outro ponto que merece destaque é o fato de que esse livro é muito fácil e divertido de ser lido. Os capítulos e seções são bem curtos, o que 
proporciona um ritmo agradável. Ele também possui um ótimo senso de humor. Não do tipo que faz você rir histericamente, mas sim aquele que te deixa confortável, como se o livro fosse uma conversa.&lt;/p&gt;

&lt;p&gt;Mas eu acho que a coisa que eu mais gosto a respeito de “O Progamador Pragmático” é que ele não é realmente focado em código, ou preso a alguma tecnologia específica, ou ferramentas específicas. Claro, ele tem sua parcela de trechos de código (principalmente Java e C/C++). Sim, ele menciona algumas ferramentas ou aplicações específicas. Mas na maior parte, &lt;strong&gt;esse livro é sobre uma mentalidade&lt;/strong&gt;. Um jeito específico de pensar, uma maneira de abordar problemas e desafios. Quando essa mentalidade, essa “filosofia pragmática”, estiver realmente enraizada na sua maneira de pensar, você será capaz de aplicá-la a diversas áreas da sua vida profissional, não apenas codifição. E eu acho que essa é realmente a maior força desse livro. Caso ele fosse focado em ferramentas ou alguma linguagem específica, eu provavelmente não estaria escrevendo sobre ele agora, quase 17 anos depois.&lt;/p&gt;

&lt;h2 id=&quot;alguns-contras&quot;&gt;Alguns contras&lt;/h2&gt;

&lt;p&gt;Claro, agora que eu já elogiei bastante esse livro, vou falar um pouco sobre os pontos negativos dele. E olha, pra ser honesto, não é tão fácil achar coisas pra criticar nele não, viu? Mas se tem algo que eu penso que a maioria dos leitores concordaria, é que certos trechos do livro estão claramente datados.&lt;/p&gt;

&lt;p&gt;Tipo, dá um tempo. Já são quase duas décadas. É incrível um livro sobre desenvolvimento de software permanecer influente por tanto tempo. É claro que pelo menos algumas partes &lt;em&gt;têm que&lt;/em&gt; estar desatualizadas. Por exemplo, uma das dicas é “sempre use controle de versão”. Hoje em dia, controle de versão é algo que tomamos por garantido, qualquer desenvolvedor que se preze conhece o Github, então chega a ser engraçado ler essa recomendação. É igual quando você assiste o vídeo do Steve Jobs apresentando o primeiro iPhone, e você vê o público alucinado por causa das funcionalidades do aparelho, que podem não ser grande coisa para os padrões de hoje, mas eram incríveis naquela época. (Sim, eu sei que existem empresas por aí na qual os desenvolvedores nem ao menos sabem que existe controle de versão. Minha dica é: se você trabalha em um lugar assim, tente ensiná-los sobre controle de versão. Se der certo, ótimo! Se não, saia daí o mais rápido possível.)&lt;/p&gt;

&lt;p&gt;Em outro trecho do livro, eles explicam uma ténica chamado “desenvolvimento tracer-bullet”. O nome pode ser um pouco estranho, mas quando eles começam a explicação, você pode perceber que é bastante parecido com o conceito de “mínimo produto viável”, que você talvez tenha aprendido nas metodologias ágeis.&lt;/p&gt;

&lt;p&gt;O que não deveria ser uma empresa, já que Andy Thomas e Dave Hunt estavam entre os signatários do já lendário &lt;a href=&quot;http://agilemanifesto.org/iso/ptbr/&quot;&gt;Manifesto Para Desenvolvimento Ágil de Software&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;concluso&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;É por isso que é difícil achar algo pra criticar nesse livro. Veja bem, ele pode parecer um pouco datado &lt;strong&gt;hoje em dia&lt;/strong&gt;, mas isso é justamente porque os autores estavam a frente de seu tempo. Algumas coisas que são comuns e óbvias hoje, eram totalmente não-óbvias e até mesmo contra-intuitivas quase 20 anos atrás. Foi preciso muita visão para escrever esse livro, e é por causa disso, e tudo o mais acima, que eu acredito que esse livro é uma leitura digna do seu tempo.&lt;/p&gt;
</description>
        <pubDate>Mon, 14 Mar 2016 00:00:00 -0300</pubDate>
        <link>http://carlosschults.net/pt/resenha-livro-programador-pragmatico/</link>
        <guid isPermaLink="true">http://carlosschults.net/pt/resenha-livro-programador-pragmatico/</guid>
        
        <category>livros</category>
        
        <category>metodologias ágeis</category>
        
        
      </item>
    
      <item>
        <title>Tipos de valor e referência em C#</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://res.cloudinary.com/dz5ppacuo/image/upload/v1454161644/value-reference-types-1038x437_tutiht.png&quot; alt=&quot;&quot; /&gt;
Este é o meu primeiro post pra valer aqui no meu blog, e eu decidi escrever sobre tipos de valor e tipos de referência em C#. Isso é um assunto relativamente básico, no sentido de que é algo que você já deveria entender caso você programe em C# profissionalmente. Mas ao mesmo tempo, é algo que pode ser um pouco contra-intuitivo caso você não seja um desenvolvedor experiente.
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;Eu vou tentar deixar o post o mais simples e curto possível, então não vou falar hoje sobre imutabilidade de string, &lt;em&gt;boxing&lt;/em&gt;, &lt;em&gt;unboxing&lt;/em&gt;, e outras coisas com nomes chiques.
Vou escrever sobre essas coisas no futuro, mas por hoje vamos focar no básico.&lt;/p&gt;

&lt;p&gt;Então, dê uma olhada no código a seguir:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;WriteLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;O valor de x é {x}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//Imprime &quot;O valor de x é 10&quot;
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;WriteLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;O valor de y é {y}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Imprime&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;O valor de y é 11&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Nenhuma surpresa até aqui, esse é exatamente o comportamento que você esperaria. Agora, imagine que nós temos uma classe assim:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Pessoa&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Nome&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Profissao&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Pessoa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nome&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;profissao&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Nome&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nome&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Profissao&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;profissao&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;DizerOi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;WriteLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Oi! Meu nome é {Nome} e eu sou {Profissao}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Agora, faça o seguinte:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;&lt;span class=&quot;n&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pessoa&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Pessoa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Maria&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;programadora&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;    
&lt;span class=&quot;n&quot;&gt;pessoa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;DizerOi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// imprime &quot;Oi! Meu nome é Maria e eu sou programadora&quot;
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pessoa2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pessoa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pessoa2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Nome&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;João&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pessoa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Profissao&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;músico&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    
&lt;span class=&quot;n&quot;&gt;pessoa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;DizerOi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// imprime &quot;Oi! Meu nome é João e eu sou músico&quot;  
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pessoa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;DizerOi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imprime&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Oi! Meu nome é João e eu sou músico&quot;&lt;/span&gt;  &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Esse é o momento no qual iniciantes costumam ficar confusos. “Isso não faz sentido”, eles dizem. “Eu mudei o valor de uma das variáveis, e a outra também mudou.” Bem, essa é a maneira errada de enxergar o que aconteceu. Na verdade, você &lt;strong&gt;não&lt;/strong&gt; mudou o valor da varíavel, e esse é o ponto.&lt;/p&gt;

&lt;p&gt;Lembra do primeiro exemplo? Vamos dar uma olhada nele novamente, dessa vez passo-a-passo:&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;A figura mostra um trecho de código C# no qual a variável é criada e lhe é atribuído o valor 10&quot; src=&quot;http://res.cloudinary.com/dz5ppacuo/image/upload/v1454161625/fig1_czxki5.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Nós declaramos a primeira variável e atribuímos o valor 10 a ela. Agora, em algum lugar dentro da memória do computador, existe uma “caixa” com o nome de x, e dentro dessa caixa tem o valor 10.&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;A figura mostra um trecho de código C# no qual a variável y é criada e recebe o valor da variável x&quot; src=&quot;http://res.cloudinary.com/dz5ppacuo/image/upload/v1454165139/fig2_de8azi.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Nós declaramos a segunda variável e atribuímos a ela o valor da primeira variável. Note que o valor é copiado de x para y. Agora nós temos duas caixas, uma chamada x e a outra y, e ambas guardam o valor 10.&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;A figura mostra um trecho de código em C# no qual o valor da variável y é incrementado em 1&quot; src=&quot;http://res.cloudinary.com/dz5ppacuo/image/upload/v1454165134/fig3_sdjbze.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Finalmente, nós incrementamos o valor da variável y em 1. Note que o valor de x permanece inalterado. Claro, por que eles realmente não tem nada a ver um com outro! Por outro lado, algo bem diferente acontece quando você está lidando com tipos de referência. Para entender isso, vamos repassar o segundo exemplo, também passo-a-passo:&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;A figura mostra um trecho de código C# no qual a variável pessoa é criada e recebe uma nova instância da classe Pessoa&quot; src=&quot;http://res.cloudinary.com/dz5ppacuo/image/upload/v1454165141/fig4_xivrng.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Primeiramente, nós criamos uma variável chamada pessoa e atribuímos a ela uma nova instância da classe Pessoa. Agora, em algum lugar na memória do computador vive uma caixa chamada “pessoa”. Note, porém que nossa variável pessoa guarda &lt;strong&gt;uma referência que aponta para a instância da classe Pessoa, ao invés de guardar a própria instância!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;A figura mostra a criação da variável pessoa2, que logo em seguida recebe o valor da variável pessoa&quot; src=&quot;http://res.cloudinary.com/dz5ppacuo/image/upload/v1454165138/fig5_i21mgj.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;No segundo passo, criamos a variável “pessoa2” e atribuímos a ela o valor da variável “pessoa.” Assim como no exemplo anterior, o valor de uma variável é copiado para a outra. Nesse caso, &lt;strong&gt;o valor que é copiado é a referência que aponta para a instância de pessoa&lt;/strong&gt;. Então agora nós temos duas variáveis cujos valores são referências que apontam para a mesma instância da classe Pessoa.&lt;/p&gt;

&lt;p&gt;Agora, é claro que quando você mudar os dados do objeto (por exemplo, mudar o nome e/ou profissão da pessoa) parece que as duas variáveis foram alteradas. Na verdade, os valores das variáveis continuam exatamente o mesmo: o que foi realmente alterado é o objeto para o qual elas apontam.&lt;/p&gt;

&lt;p&gt;Então, podemos resumir da seguinte forma: tipos de valor armazenam dados. Quando você atribuir o valor de uma variável a outra, o que é copiado são os próprios dados (como um número inteiro, por exemplo). Isso é parecido com quando você copia um arquivo de uma pasta em seu computador e cola em outro lugar. Você fez uma cópia, mas de agora em diante eles são arquivos independentes e não têm nada a ver um com o outro.&lt;/p&gt;

&lt;p&gt;Tipos de referência armazenam uma referência, que apontam para os dados, que vivem em algum outro lugar na memória do computador. Quando você atribui o valor de uma variável de referência para outra, o que é copiado é a referência. Pode ser útil pensar nas referências como atalhos para arquivos. Se você tem um ou mais atalhos que apontam para um arquivo em particular no seu HD, quando você fizer alterações no arquivo, tais alterações serão visíveis quando você acessar o arquivo pelo atalho. Pois eles não passam disso, atalhos.&lt;/p&gt;

&lt;h2 id=&quot;quais-tipos-so-tipos-de-valor&quot;&gt;Quais tipos são tipos de valor?&lt;/h2&gt;

&lt;p&gt;De acordo com o MSDN, os tipos de valor são:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Todos os tipos númericos&lt;/li&gt;
  &lt;li&gt;Boolean, Char, e Date&lt;/li&gt;
  &lt;li&gt;Todas as estruturas&lt;/li&gt;
  &lt;li&gt;Enumerações&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;quais-tipos-so-tipos-de-referncia&quot;&gt;Quais tipos são tipos de referência?&lt;/h2&gt;

&lt;p&gt;Novamente, de acordo com o MSDN:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;String&lt;/li&gt;
  &lt;li&gt;Todos os arrays&lt;/li&gt;
  &lt;li&gt;Classes&lt;/li&gt;
  &lt;li&gt;Delegates&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;espera-um-pouco-string--um-tipo-de-referncia&quot;&gt;Espera um pouco! String é um tipo de referência?!&lt;/h2&gt;

&lt;p&gt;Talvez você tenha se surpreendido em ver String listada como um tipo de referência. Afinal de contas, ela parece se comportar como um tipo de valor. Bom, a razão para isso é que a string é um tipo &lt;strong&gt;imutável&lt;/strong&gt;. Como eu disse antes, não vou falar sobre isso hoje, mas em breve teremos um post inteiro sobre System.String.&lt;/p&gt;

&lt;p&gt;Bom, por hoje é só. Espero que tenham gostado do post, e eu adoraria ter o feedback de vocês. Eu me expressei claramente? Eu disse algo um pouco impreciso - ou mesmo totalmente errado? Deixe um comentário aqui embaixo ou &lt;a href=&quot;http://twitter.com/carlosschults&quot;&gt;me chame no twitter&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;referncias-em-ingls&quot;&gt;Referências (em inglês):&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://jonskeet.uk/csharp/references.html&quot;&gt;http://jonskeet.uk/csharp/references.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/t63sy5hs.aspx&quot;&gt;https://msdn.microsoft.com/en-us/library/t63sy5hs.aspx&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 30 Jan 2016 00:00:00 -0200</pubDate>
        <link>http://carlosschults.net/pt/tipos-valor-referencia-em-csharp/</link>
        <guid isPermaLink="true">http://carlosschults.net/pt/tipos-valor-referencia-em-csharp/</guid>
        
        <category>c#</category>
        
        <category>iniciantes</category>
        
        <category>oop</category>
        
        <category>tipagem</category>
        
        
      </item>
    
      <item>
        <title>Compartilhe o que você aprende</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://res.cloudinary.com/dz5ppacuo/image/upload/v1440517439/share1038x437_mshqwf.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Compartilhe o que você sabe. Escreva um blog. Responda uma pergunta no Stack Overflow. Abra a fonte do seu código. Cria conteúdo! Na nossa área, esse conselho aparece com muita frequência, em diversas formas .&lt;/p&gt;

&lt;p&gt;E com razão, eu diria. Quantas horas de trabalho você já poupou graças a um post em algum blog? Ou a uma resposta bem feita no Stack Overflow?
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;Quantas vezes uma biblioteca/ferramenta/app open-source salvou você de ter que codificar aquela funcionalidade do zero? Se eu fosse adivinhar a resposta pra cada uma dessas perguntas, provavelmente diria: muitas.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.akitaonrails.com/2014/08/29/milesimo-1000-post-no-blog#.Vd0nh5eC7lc&quot;&gt;O desenvolvedor Rafael Rosa Fu falou um pouco sobre alguns dos benefícios da criação de conteúdo&lt;/a&gt; em um post no site do Fabio Akita:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;Aprendizado. praticar novas habilidades é importante para fixá-las, ao escrever sobre o que aprendemos estamos reforçando e expandindo nosso conhecimento ao sermos “forçados” a explicá-lo de forma que possa ser consumido por outras pessoas.&lt;/li&gt;
    &lt;li&gt;Memória - não sei você, mas minha memória é igual a de um peixinho dourado, e tenho certeza que não sou exceção. Escreva sobre aquele conceito complicado ou deixe a receita para o procedimento esporádico e quando precisar se lembrar dele abra seu blog ou procure no Google e vai encontrar suas próprias palavras para lembrá-lo.&lt;/li&gt;
    &lt;li&gt;Portfólio - especialmente útil para quem está começando na carreira, blog posts são úteis como parte de um portfólio de conhecimento que pode ser encontrado por um possível empregador ou usado como referência durante uma entrevista, agindo como um complemento ao tempo de carreira, além de ser um bom gancho para conversas durante entevistas. […]&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Jeff Atwood (co-foundador do Stack Overflow e do Discourse) diss que iniciar seu blog “foi a coisa mais importante que já fiz em toda a minha carreira”. Então, parece razoável dizer que se nós encorajarmos mais e mais pessoas a compartilhar seus conhecimentos e experiências, toda a comunidade ganha, certo?&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.smashingmagazine.com/2012/03/publish-what-you-learn/&quot;&gt;Nesse artigo publicado em 2012 pela Smashing Magazine, Louis Lazaris dá conselhos sobre como começar a publicar&lt;/a&gt;: publique as coisas que você aprende, não tenha medo de cometer erros, esteja aberto à colaboração de seus leitores.&lt;/p&gt;

&lt;p&gt;Parece fácil, não é?&lt;/p&gt;

&lt;h2 id=&quot;quando-a-dvida-chega&quot;&gt;Quando a dúvida chega&lt;/h2&gt;

&lt;p&gt;Eu tive bastante receio antes de começar esse blog. Eu quero dizer, como poderia ser de outra forma? Todos esses blogueiros bem estabelecidos, eles têm anos ou mesmo décadas de experiência. Eles palestram em vários países. Eles lançam livros, têm podcasts, eles criaram empresas bem-sucedidas ou talvez até alguma tecnologia usada por milhões de pessoas. Resumindo, eles têm uma página “Sobre Mim” bem impressionante. Caramba, alguns deles já têm até mesmo artigo na wikipédia sobre eles. &lt;strong&gt;Esses são os rockstars&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;E eu? Eu sou só um cara, dois anos depois de terminar a faculdade, tentando aprender e desenvolver minha carreia. Será que eu realmente tenho alguma coisa de valor para oferecer? Será que vou ser capaz de ajudar alguém? Ou vou ser só mais um, aumentando ainda mais o ruído da internet?&lt;/p&gt;

&lt;p&gt;Eu penso que todas essas são questões relevantes. A web é um lugar ridiculamente enorme. Você poderia compartilhar conteúdo por anos, talvez sua vida toda, sem ser notado, sem receber nenhum feedback.&lt;/p&gt;

&lt;p&gt;De vez em quando eu faço uma pesquisa no Google sobre algum assunto e acabo caindo em um blog com um design bacana e posts muito bem escritos. Eu começo a olhar os posts, e noto que a maioria deles (às vezes, todos eles) não tem nenhum comentário. Às vezes, também reparo que o último post foi escrito há dois ou três anos. Eles desistiram.&lt;/p&gt;

&lt;p&gt;E apesar disso ser triste e desencorajador, não deixa de ser apenas um fato da vida. Talvez seu blog vai atingir uma grande audiência, talvez não.&lt;/p&gt;

&lt;h2 id=&quot;por-que-eu-criei-esse-blog-afinal-de-contas&quot;&gt;Por que eu criei esse blog, afinal de contas?&lt;/h2&gt;

&lt;p&gt;Talvez a seção anterior tenha lhe dado a impressão de que eu sou cético com relação aos benefícios da criação de conteúdo. E talvez eu realmente seja, um pouco. Mas eu não vou deixar que isso me impeça. Eu acredito na importância de contribuir com a comunidade.&lt;/p&gt;

&lt;p&gt;Se lembra daquela resposta no Stack Overflow que salvou seu emprego? Então, adivinha: alguém “perdeu” o tempo para escrever aquela resposta, de graça, e para postá-la na internet, de graça, pra que toda a internet veja, pra sempre. Isso não é incrível? Eu penso que parte da beleza da nossa profissão é o fato de que há tantas pessoas dispostas a compartilhar conhecimento de graça. A sacrificar seu tempo livre para conseguir construir alguma coisa. Milagres como GitHub, Stack Overflow, Wikipédia, só se tornam possíveis graças a essas pessoas. E eu quero ser parte disso.&lt;/p&gt;

&lt;p&gt;Claro, você poderia argumentar que essas pessoas fazem esse tipo de coisa movidas pelos seus próprios motivos egoistas. É, talvez sim, mas o ponto é: no fim das contas, isso não importa nem um pouco.
Resultados importam. Se a usuária MariaDaSilva escreveu aquela resposta no Stack Overflow só pra ganhar alguns pontinhos de reputação, por mim está ótimo. Eu quero apenas a resolução do meu problema.&lt;/p&gt;

&lt;p&gt;Então é isso. Para usar uma metáfora do mundo dos torrents, eu cansei de ser apenas um parasita. É hora de semear também.&lt;/p&gt;
</description>
        <pubDate>Tue, 25 Aug 2015 00:00:00 -0300</pubDate>
        <link>http://carlosschults.net/pt/compartilhe-o-que-voce-aprende/</link>
        <guid isPermaLink="true">http://carlosschults.net/pt/compartilhe-o-que-voce-aprende/</guid>
        
        <category>blog</category>
        
        <category>compartilhar</category>
        
        <category>primeiro post</category>
        
        
      </item>
    
  </channel>
</rss>
