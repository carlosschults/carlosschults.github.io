<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>carlos schults / blog</title>
    <description>Artigos sobre desenvolvimento de software, banco de dados e vários assuntos ligados à tecnologia.</description>
    <link>http://carlosschults.net/</link>
    <atom:link href="http://carlosschults.net/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 06 Mar 2017 21:24:26 -0300</pubDate>
    <lastBuildDate>Mon, 06 Mar 2017 21:24:26 -0300</lastBuildDate>
    <generator>Jekyll v3.1.2</generator>
    
    
      <item>
        <title>Já está na hora de começar a usar essas features do C# 6!</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://res.cloudinary.com/dz5ppacuo/image/upload/v1487896790/csharp6features_y5czrf.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;A sétima versão do C# está chegando, e vai provavelmente trazer várias funcionalidades novas e úteis para nossas  caixas de ferramentas. Mas deixa eu perguntar uma coisa: você já está usando as funcionalidades da versão anterior?
 &lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;Alguns dias atrás eu estava pensando sobre qual seria o tema do próximo post. Nada mais natural que escrever sobre o C# 7, já que &lt;a href=&quot;https://blogs.msdn.microsoft.com/visualstudio/2017/02/09/visual-studio-2017-launch-event-and-20th-anniversary/&quot;&gt;seu lançamento, junto com o Visual Studio 2017, é amanhã.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Mas então eu percebi que, mesmo já fazendo cerca de dois anos desde o lançamento do C# 6, alguns desenvolvedores ainda não se sentem confortáveis o suficiente com as funcionalidades da versão, de maneira a não incorporá-las em seu código.&lt;/p&gt;

&lt;p&gt;Assim, eu decidi voltar um pouco e escrever sobre as funcionalidades do C# 6 no lugar disso. Não todas, mas aquelas que podem tornar seu código mais limpo e expressivo, e que são simples o suficiente para você já sair usando!&lt;/p&gt;

&lt;h2 id=&quot;interpolao-de-string&quot;&gt;Interpolação de String&lt;/h2&gt;

&lt;p&gt;Suponha que nós temos uma classe chamada &lt;code class=&quot;highlighter-rouge&quot;&gt;Person&lt;/code&gt;, com duas propriedades somente-leitura, &lt;code class=&quot;highlighter-rouge&quot;&gt;Name&lt;/code&gt; e &lt;code class=&quot;highlighter-rouge&quot;&gt;Age&lt;/code&gt;. Algo assim:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/carlosschults/84db03cd2a530530b72c4b9eeeb738d4.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Então nós adicionamos um método chamado &lt;code class=&quot;highlighter-rouge&quot;&gt;Introduce&lt;/code&gt;, para que nossas pessoas sejam capazes de se apresentar. Para uma pessoa de 22 anos chamada Maria, o método deve retornar “Hi! My name is Maria and I’m 22 years old.”&lt;/p&gt;

&lt;p&gt;Tem algumas maneiras diferentes de se fazer isso na versão 5 do C#, como você pode ver na seguinte listagem:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/carlosschults/9e30324951420356397c5cc8f50ea51b.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Cada uma delas tem suas vantagens e desvantagens, claro, mas o C# 6 disponibiliza um novo jeito:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/carlosschults/17f501bd6d0ce6f5938edf17ef8e8704.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Apenas coloque um cifrão no início da string, coloque suas variáveis dentro de chaves, e é isso!&lt;/p&gt;

&lt;p&gt;Interpolação de strings não funciona para todas as ocasiões. Se você precisa de uma formatação especial nos valores, você ainda teria de usar &lt;code class=&quot;highlighter-rouge&quot;&gt;string.Format()&lt;/code&gt;, por exemplo.&lt;/p&gt;

&lt;p&gt;Mas no dia-a-dia, eu uso interpolação na maioria das vezes que preciso fazer concatenação de strings. Eu acho essa forma bem mais interessante e mais clara do que as outras opções.&lt;/p&gt;

&lt;h2 id=&quot;initializers-para-propriedades-automticas&quot;&gt;Initializers para propriedades automáticas&lt;/h2&gt;

&lt;p&gt;Continuando com o exemplo anterior. Vamos supor que nós precisamos de um construtor sem parâmetros em nossa classe. Junto com isso, vamos precisar disponibilizar valores padrão para &lt;code class=&quot;highlighter-rouge&quot;&gt;Name&lt;/code&gt; e &lt;code class=&quot;highlighter-rouge&quot;&gt;Age&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Do contrário, o método &lt;code class=&quot;highlighter-rouge&quot;&gt;Introduce()&lt;/code&gt; retornaria “Hi! My name is  and I’m 0 years old.” E não iríamos querer isso, né?&lt;/p&gt;

&lt;p&gt;No C# 5, nós teríamos que inicializar as propriedades dentro do construtor:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/carlosschults/d95cade5d8d5f245a1d6bb49ef2feb1f.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Já a sexta versão da linguagem nos permite definir valores padrão para as propriedades no mesmo momento em que as declaramos:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/carlosschults/e7d56c032e723f7c5110a9e3bfa1c744.js&quot;&gt;&lt;/script&gt;

&lt;h2 id=&quot;operador-condicional-nulo&quot;&gt;Operador condicional nulo&lt;/h2&gt;

&lt;p&gt;Considere o código a seguir:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/carlosschults/7fb5caff2e73f4130f4db982825adbe6.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Nada demais, não é? Mas tem um problema esperando para acontecer aqui. Se &lt;code class=&quot;highlighter-rouge&quot;&gt;customer&lt;/code&gt; é &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;, esse código vai disparar uma &lt;code class=&quot;highlighter-rouge&quot;&gt;NullReferenceException&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;É nesse momento que o “Operador condicional nulo” vem a calhar:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/carlosschults/65bc4372a0e4fc3e8f38c0ee57905beb.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;O que o código acima faz? Simples: se &lt;code class=&quot;highlighter-rouge&quot;&gt;customer&lt;/code&gt; não é &lt;code class=&quot;highlighter-rouge&quot;&gt;nulo&lt;/code&gt;, a propriedade &lt;code class=&quot;highlighter-rouge&quot;&gt;Address&lt;/code&gt; é acessada normalmente, e seu valor é atribuído à nossa variável local. No entanto, se &lt;code class=&quot;highlighter-rouge&quot;&gt;customer&lt;/code&gt; &lt;em&gt;é&lt;/em&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;, a expressão toda é avaliada para nulo, e é isso que a variável recebe.&lt;/p&gt;

&lt;p&gt;Outra coisa legal a respeito desse operador é que você pode usá-lo em conjunto com o &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ms173224.aspx&quot;&gt;Operador Null Coalesce&lt;/a&gt; para disponibilizar, de maneira fácil, um valor default diferente de &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/carlosschults/e17d34ba939fb7c472e164010db56377.js&quot;&gt;&lt;/script&gt;

&lt;h2 id=&quot;mtodos-e-propriedades-expression-bodied&quot;&gt;Métodos e propriedades “Expression-bodied”&lt;/h2&gt;

&lt;p&gt;Essa é bem fácil. Trata-se de uma maneira mais curta de escrever métodos, utilizando a sintaxe das expressões lambda.&lt;/p&gt;

&lt;p&gt;Por exemplo, os dois métodos a seguir fazem a mesma coisa:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/carlosschults/eeae77f3876f9b692ca667281b5401d0.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Essa funcionalidade não é restrita a métodos. Ela também pode ser usada com propriedades (de apenas leitura) e indexadores.&lt;/p&gt;

&lt;h2 id=&quot;concluso&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Parece claro que o objetivo da Microsoft  com a sexta versão do C# não era adicionar funcionalidades radicalmente novas à linguagem.&lt;/p&gt;

&lt;p&gt;Ao invés disso, a intenção era permitir aos desenvolvedores escrever código de uma maneira mais clara e concisa. E em minha opinião, o objetivo foi alcançado.&lt;/p&gt;

&lt;p&gt;Você pode pensar que algumas das funcionalidades não fazem tanta diferença, na prática. Eu discordo. C# é frequentemente acusado de ser muito verboso. Existem situações nas quais você precisa escrever uma quantidade razoável de código para fazer algo que em Ruby ou Python poderia ser feito em uma linha.&lt;/p&gt;

&lt;p&gt;E isso é normal. Um pouco (a maioria) da já mencionada verbosidade vem do fato de C# ser uma linguagem estaticamente tipada, e eu digo: &lt;strong&gt;sou feliz por isso&lt;/strong&gt;. Eu não consigo contar a quantidade de vezes que o compilador me salvou, pegando meus erros idiotas.&lt;/p&gt;

&lt;p&gt;Se um pouco de verbosidade é o preço que tenho que pagar por isso, que seja.&lt;/p&gt;

&lt;p&gt;Tudo isto dito, os detratores têm uma certa razão. É possível ser verboso &lt;em&gt;excessivamente&lt;/em&gt;. Então, qualquer funcionalidade que me permite eliminar um pouco dessa verbosidade extra e escrever código mais conciso é muito bem vinda.&lt;/p&gt;

&lt;h2 id=&quot;veja-mais&quot;&gt;Veja mais&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://geekswithblogs.net/WinAZ/archive/2015/06/30/whatrsquos-new-in-c-6.0-auto-property-initializers.aspx&quot;&gt;http://geekswithblogs.net/WinAZ/archive/2015/06/30/whatrsquos-new-in-c-6.0-auto-property-initializers.aspx&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/magazine/dn802602.aspx&quot;&gt;https://msdn.microsoft.com/en-us/magazine/dn802602.aspx&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.caelum.com.br/novidades-do-c-6-0/&quot;&gt;http://blog.caelum.com.br/novidades-do-c-6-0/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 06 Mar 2017 00:00:00 -0300</pubDate>
        <link>http://carlosschults.net/pt/funcionalidades-csharp-6/</link>
        <guid isPermaLink="true">http://carlosschults.net/pt/funcionalidades-csharp-6/</guid>
        
        <category>csharp</category>
        
        <category>iniciantes</category>
        
        
      </item>
    
      <item>
        <title>Aprenda quais tipos de comentários devem ser evitados</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://res.cloudinary.com/dz5ppacuo/image/upload/v1488499558/comments-1038x437.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Alerta de Spoiler: Você deveria evitar a maioria.
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;“Comentar ou não comentar”. Essa é uma questão que gera debates acalorados. Algumas pessoas dizem que comentários são indispensáveis. Outros defendem que comentários apenas mostram a incapacidade do desenvolvedor de se expressar claramente no código. Quem está certo?&lt;/p&gt;

&lt;p&gt;Na época da faculdade, eu considerava comentários indispensáveis na hora de programar. Do contrário, como você poderia entender o que código deveria fazer?&lt;/p&gt;

&lt;p&gt;Depois de me formar e encontrar um emprego, as coisas começaram a mudar. Eu comecei a ser exposto à &lt;em&gt;código real&lt;/em&gt;. Eu estava lendo livros, artigos e blog posts escritos por pessoas influentes da área.&lt;/p&gt;

&lt;p&gt;Todas essas experiências moldaram a minha visão atual.&lt;/p&gt;

&lt;h2 id=&quot;os-perigos-da-documentao-ruim&quot;&gt;Os perigos da documentação ruim&lt;/h2&gt;

&lt;p&gt;Comentários são apenas outra forma de documentação. E não se engane: documentação é uma coisa boa - &lt;em&gt;quando feita corretamente e na quantidade certa&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Infelizmente, é feita errada frequentemente!&lt;/p&gt;

&lt;p&gt;Muitos tipos de documentação podem ser problemáticas. É muito comum que a documentação perca sincronia com o que está documentando, o que é bem pior que não ter documentação nenhuma para começar.&lt;/p&gt;

&lt;p&gt;Esse é um dos problemas dos quais comentários sofrem, mas está longe de ser o único.&lt;/p&gt;

&lt;h3 id=&quot;cdigo-comentado&quot;&gt;Código comentado&lt;/h3&gt;

&lt;p&gt;Vamos começar com o problema mais óbvio de todos, que é código comentado. Alguns desenvolvedores, durante uma correção de bug por exemplo, decidem comentar o código que está errado, em vez de removê-lo.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Não faça isso!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Código comentado não traz benefício para ninguém. É apenas desperdício. Confie no seu sistema de controle de versão. Ele vai lembrar das alterações feitas caso seja necessário revertê-las no futuro.&lt;/p&gt;

&lt;h3 id=&quot;comentrios-changelog&quot;&gt;Comentários ‘Changelog’&lt;/h3&gt;

&lt;p&gt;Esta categoria de comentários ruins é parecida com a anterior, no sentido de ser causada por uma falta de confiança no sistema de controle de versões.&lt;/p&gt;

&lt;p&gt;O que eu quero dizer por comentários changelog? Comentários que servem apenas para listar as alterações feitas a um arquivo.&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/carlosschults/3889e4d4b337c6adc94af354ec574d9a.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Comentários desse tipo estão apenas fazendo o mesmo trabalho que seu controle de versão, mas de uma maneira desajeitada e propensa ao erro.&lt;/p&gt;

&lt;p&gt;Não escreve comentários como esses. Use &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt; e seja feliz.&lt;/p&gt;

&lt;h3 id=&quot;comentrios-redundantes&quot;&gt;Comentários redundantes&lt;/h3&gt;

&lt;p&gt;Esse tipo de comentário ruim é muito fácil de detectar e corrigir. Considere o código a seguir:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/carlosschults/cc821bc3c00137e5fad68f1fe7d65490.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Eu acho que todos podemos concordar que esses comentários são inúteis. O código é perfeitamente claro sem eles, portanto, devem ser removidos.&lt;/p&gt;

&lt;h3 id=&quot;comentrios-delimitando-fim-de-blocos&quot;&gt;Comentários delimitando fim de blocos&lt;/h3&gt;

&lt;p&gt;Você provavelmente já viu algum código assim antes:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/carlosschults/0c6e461ec278db804f52d64ade458bf4.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Algumas pessoas escrevem comentários assim para não perderem o controle das chaves.&lt;/p&gt;

&lt;p&gt;Se você precisa de comentários por essa razão, isso é indicativo de que seu método é muito longo e você tem muitos níveis de indentação.&lt;/p&gt;

&lt;p&gt;Lembre-se do Princípio da Responsabilidade Única: cada método deve fazer apenas uma coisa. Divida o seu método em métodos menores e a necessidade desse tipo de comentários desaparece.&lt;/p&gt;

&lt;h3 id=&quot;comentrios-que-delimitam-sees-dentro-de-um-mtodo&quot;&gt;Comentários que delimitam seções dentro de um método&lt;/h3&gt;

&lt;p&gt;Esse é parecido com o anterior. Se você tem diversas seções dentro de um método, cada uma delas com um comentário explicativo em cima, então você provavelmente está violando o Princípio da Responsabilidade Única.&lt;/p&gt;

&lt;p&gt;Extraia cada trecho para seu próprio método, usando o texto do comentário como o nome do novo método, e então remova os comentários.&lt;/p&gt;

&lt;h3 id=&quot;comentrios-desatualizados&quot;&gt;Comentários desatualizados.&lt;/h3&gt;

&lt;p&gt;Um cenário comum:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Bob escreve algumas linhas de código. Ele decide que o código não está claro o suficiente e adiciona alguns comentários para tornar a sua intenção mais clara.&lt;/li&gt;
  &lt;li&gt;Passam-se algumas semanas. Alguém descobre um bug no código de Bob. Mas ele está de férias, então Alice é encarregada de corrigir o bug.&lt;/li&gt;
  &lt;li&gt;Alice corrige o código em alguns minutos e comita suas alterações. Mas ela esquece de alterar os comentários para refletir as mudanças que ela fez no código.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;O que nós temos agora? Comentários mentirosos!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Documentação que espalha mentiras é pior que não ter documentação alguma.&lt;/strong&gt; É uma fonte de confusão para os desenvolvedores, e terreno fértil para bugs. Quando você ver um comentário desatualizado, não pense duas vezes: remova-o imediatamente, ou corrija-o. Mas na maioria das vezes você não deveria manter o comentário. Veja o próximo tópico para descobrir o porquê.&lt;/p&gt;

&lt;h3 id=&quot;comentrios-criados-devido--falta-de-expressividade-no-cdigo&quot;&gt;Comentários criados devido à falta de expressividade no código&lt;/h3&gt;

&lt;p&gt;Considere o código a seguir:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/carlosschults/ec7db3ebadccded768f97933c88e704f.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;Talvez você não considere o comentário no trecho acima tão ruim. Tudo bem, não é péssimo. Mas pense na oportunidade perdida de extrair um método ou propriedade útil:&lt;/p&gt;

&lt;script src=&quot;https://gist.github.com/carlosschults/b102a4f5c11ba7b1639410dcbb87830f.js&quot;&gt;&lt;/script&gt;

&lt;p&gt;No novo código, nós extraímos o conceito de ser elegível para doar sangue para uma nova propriedade. As regras para elegibilidade para doação de sangue estão agora consolidadas em um único local; se elas mudarem algum dia, a quantidade de trabalho necessária para atualizá-las será mínima.&lt;/p&gt;

&lt;p&gt;E nós ainda ganhamos o benefício adicional da legibilidade: a nova instrução &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt; lê quase como linguagem natural.&lt;/p&gt;

&lt;h2 id=&quot;concluso&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Como vimos, há diversos tipos de comentários ruins com os quais você deve ficar alerta. Eles geralmente são sinais de que há algo errado no seu código. Talvez seus métodos são muito longos.Talvez &lt;a href=&quot;http://carlosschults.net/pt/como-escolher-bons-nomes/&quot;&gt;você não escolheu bons nomes para suas variáveis&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Toda vez que você sentir a necessidade de escrever um comentário, pare e tente pensar em maneiras de melhorar o seu código para tornar o comentário desnecessário.&lt;/p&gt;

&lt;p&gt;Nem todos os comentários são ruins. Em um post futuro, vou falar sobre os tipos de comentários que são úteis.&lt;/p&gt;

&lt;p&gt;Até mais!&lt;/p&gt;

&lt;h2 id=&quot;ler-mais-todos-os-links-em-ingls&quot;&gt;Ler mais (todos os links em inglês)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://butunclebob.com/ArticleS.TimOttinger.ApologizeIncode&quot;&gt;Apologies In Code, por Robert C. Martin&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.codeproject.com/tips/467657/write-comments-that-matter&quot;&gt;Write comments that matter, por Sander Rossel&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/@kentcdodds/please-don-t-commit-commented-out-code-53d0b5b26d5f#.yex54k2sg&quot;&gt;Please, don’t commit commented out code, por Kent C. Dodds&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 02 Mar 2017 00:00:00 -0300</pubDate>
        <link>http://carlosschults.net/pt/tipos-de-comentarios-a-evitar/</link>
        <guid isPermaLink="true">http://carlosschults.net/pt/tipos-de-comentarios-a-evitar/</guid>
        
        <category>code smell</category>
        
        <category>BoasPraticas</category>
        
        <category>iniciantes</category>
        
        
      </item>
    
      <item>
        <title>Blogs em português sobre desenvolvimento de software que você deveria seguir!</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://res.cloudinary.com/dz5ppacuo/image/upload/v1486838693/capa-min_gdaepw.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Para o bem ou para o mal, o idioma da tecnologia é o inglês. Mas isso não significa que não existe conteúdo de qualidade sendo produzido na nossa língua.
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;O inglês é a língua franca da tecnologia, como eu já &lt;a href=&quot;http://carlosschults.net/pt/programar-portugues-ou-ingles/&quot;&gt;disse quando expus minha opinião sobre a controvérsia de se programar em inglês ou português.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Além das oportunidades que saber inglês pode lhe trazer, eu acredito que o maior benefício que você consegue é ter acesso a muita informação de qualidade.&lt;/p&gt;

&lt;p&gt;Porém, isso não quer dizer que não exista informação de qualidade sendo publicada na nossa língua. Seguem agora três blogs que você já deveria estar acompanhando:&lt;/p&gt;

&lt;h2 id=&quot;object-pascal-programming&quot;&gt;Object Pascal Programming&lt;/h2&gt;

&lt;p&gt;Vamos começar a lista com o &lt;a href=&quot;http://objectpascalprogramming.com/&quot;&gt;Object Pascal Programming&lt;/a&gt;, blog do &lt;a href=&quot;https://github.com/mdbs99/&quot;&gt;Marcos Douglas Santos&lt;/a&gt;, o qual eu citei no meu &lt;a href=&quot;carlosschults.net/pt/metodos-privados-code-smell/&quot;&gt;último post&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Conheci esse site há cerca de dois meses, por acaso, e desde então tenho lido todos os artigos, que são publicados assiduamente toda semana.&lt;/p&gt;

&lt;p&gt;Talvez vocês estejam se perguntando o que há de tão interessante em um blog de Object Pascal para um programador C#? Aí é que está: não se deixem enganar pelo título. Marcos escreve sobre conceitos e boas práticas da orientação a objetos, de uma forma que é aplicável para a maioria da linguagens que seguem esse paradigma.&lt;/p&gt;

&lt;p&gt;Quando há exemplos de código, esses são escritos em Object Pascal, mas são simples e claros o bastante para que você consiga seguir, independente de ter ou não experiência com essa linguagem.&lt;/p&gt;

&lt;p&gt;Além da qualidade dos artigos em si, é importante citar ótimo trabalho que Marcos tem feito em fomentar uma comunidade em torno do blog, com o uso de redes sociais, chat e lista de e-mail.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://objectpascalprogramming.com/&quot;&gt;Recomendadíssimo&lt;/a&gt;!&lt;/p&gt;

&lt;h2 id=&quot;robson-castillo&quot;&gt;Robson Castillo&lt;/h2&gt;

&lt;p&gt;O &lt;a href=&quot;https://twitter.com/nosborcastilho&quot;&gt;Robson&lt;/a&gt; publica em seu &lt;a href=&quot;https://robsoncastilho.com.br/&quot;&gt;blog&lt;/a&gt; desde 2010, e aborda uma gama bem diversa de assuntos.&lt;/p&gt;

&lt;p&gt;Ele já escreveu sobre tecnologias específicas, como tutoriais de ASP.NET MVC, passando por assuntos mais “&lt;em&gt;high level&lt;/em&gt;” como arquitetura de software, Design Patterns e boas práticas de codificação, sem esquecer das metodologias ágeis e gerenciamento de carreira.&lt;/p&gt;

&lt;p&gt;Uma área muito bacana neste blog é a &lt;a href=&quot;https://robsoncastilho.com.br/livros-indicados/&quot;&gt;página de leituras recomendadas&lt;/a&gt;. Apesar da avalanche de informação disponível na Web, eu acredito que livros ainda têm um lugar importante no aprendizado de desenvolvedores, e vejo que Robson compartilha da minha visão.&lt;/p&gt;

&lt;p&gt;Embora existam alguns posts que são específicos a .Net e C#, a grande maioria não é. Então, independente de qual seja a linguagem que você usa, pode ir sem medo que você vai encontrar conteúdo de qualidade no blog do Robson.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://robsoncastilho.com.br/&quot;&gt;Não deixe de conferir&lt;/a&gt;!&lt;/p&gt;

&lt;h2 id=&quot;elemar-jr&quot;&gt;Elemar Jr&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://twitter.com/elemarjr&quot;&gt;Elemar Jr&lt;/a&gt; é um nome bastante conhecido na comunidade .NET. Assim como Robson, ele &lt;a href=&quot;http://elemarjr.com/pt/home/&quot;&gt;publica em seu blog desde 2010&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Elemar é conhecido por ser incrivelmente prolífico, escrevendo sobre um número impressionante de tópicos. Existe um certo viés para C#, mas ele também aborda diversas outras linguagens, tecnologias e técnicas, como C++, F#, Haskell, HTML, Javascript, testes automatizados, arquitetura, e muito mais.&lt;/p&gt;

&lt;p&gt;Um aspecto interessante do blog do Elemar é que ele não para no conteúdo técnico, explorando também tópicos como filosofia, política, psicologia, economia, entre outros, o que eu acho valiosíssimo. Nós, desenvolvedores, às vezes só conversamos com outros desenvolvedores, sobre desenvolvimento, e isso não é saudável.&lt;/p&gt;

&lt;p&gt;Nos reconectar com o mundo ao nosso redor é necessário para uma vida equilibrada. E no lado profissional, nos envolver com as humanidades também melhora a nossa visão do negócio e de como o código que escrevemos é apenas um meio para gerar valor para nossos clientes e nossas empresas.&lt;/p&gt;

&lt;p&gt;Recentemente, Elemar &lt;a href=&quot;http://elemarjr.com/pt/2016/04/17/por-que-comecei-a-blogar-em-ingles/&quot;&gt;começou a blogar também em inglês&lt;/a&gt;, o que é uma iniciativa com a qual eu naturalmente &lt;a href=&quot;http://carlosschults.net&quot;&gt;concordo&lt;/a&gt; ;)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://elemarjr.com/pt/home/&quot;&gt;Boa leitura&lt;/a&gt;!&lt;/p&gt;

&lt;h2 id=&quot;concluso&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Você deve estar se perguntando porque mantive o número de blogs recomendados baixo. Um dos motivos é que, com esses três blogs, você já tem leitura de sobra para muito tempo (isso se formos considerar apenas os artigos já publicados. É claro que os blogs estão na ativa, então mais posts continuarão vindo).&lt;/p&gt;

&lt;p&gt;O segundo - e mais importante - motivo é que sou &lt;em&gt;bastante exigente com o que leio&lt;/em&gt;. Não gosto de perder tempo com textos pessimamente escritos, com argumentos sem embasamento, ou com títulos sensacionalistas apenas para ganhar cliques.&lt;/p&gt;

&lt;p&gt;Evidentemente, nenhum dos três blogs acima tem essas características. Você ter a certeza que os blogs recomendados nesse post oferecem um conteúdo de alta qualidade, capaz de aumentar seu conhecimento e trazer benefícios para a sua carreira.&lt;/p&gt;

&lt;p&gt;E você, tem algum blog que gostaria de recomendar? Compartilhe com a gente nos comentários.&lt;/p&gt;

&lt;p&gt;Até a próxima!&lt;/p&gt;
</description>
        <pubDate>Sat, 11 Feb 2017 00:00:00 -0200</pubDate>
        <link>http://carlosschults.net/pt/blogs-desenvolvimento-portugues/</link>
        <guid isPermaLink="true">http://carlosschults.net/pt/blogs-desenvolvimento-portugues/</guid>
        
        <category>recomendacoes</category>
        
        
      </item>
    
      <item>
        <title>Métodos privados são um &#39;Code Smell&#39;?</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://res.cloudinary.com/dz5ppacuo/image/upload/v1485700794/capa-min_no1cci.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Algumas pessoas acham que métodos privados devem ser evitados. Será que elas estão certas?
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;Há uns dois meses, &lt;a href=&quot;https://twitter.com/mdbs99&quot;&gt;Marcos Douglas&lt;/a&gt; publicou um post &lt;a href=&quot;http://objectpascalprogramming.com/posts/menos-e-mais/&quot;&gt;sobre como o uso de regras e restrições pode melhorar seu código&lt;/a&gt;. Essa &lt;a href=&quot;https://medium.com/@cscalfani/why-programmers-need-limits-3d96e1a0a6db#.rptqu89ec&quot;&gt;premissa&lt;/a&gt; costuma aparecer &lt;a href=&quot;http://blog.ploeh.dk/2015/04/13/less-is-more-language-features/&quot;&gt;de novo&lt;/a&gt; e &lt;a href=&quot;https://robots.thoughtbot.com/sandi-metz-rules-for-developers&quot;&gt;de novo&lt;/a&gt; pela web, e eu concordo totalmente com ela.&lt;/p&gt;

&lt;p&gt;Marcos mostra várias orientações úteis, tais como o número ideal de argumentos em um método, o número ideal de métodos, em uma classe, e assim por diante. O artigo é muito bom, e eu recomendo a todos vocês que o &lt;a href=&quot;https://gist.github.com/carlosschults/5f4ba7cfb2453977c8d11424b2926686&quot;&gt;leiam &lt;/a&gt;, mas ele não é o foco do meu post hoje.&lt;/p&gt;

&lt;p&gt;Hoje, o que eu realmente quero falar é de um assunto que surgiu na área de comentários do artigo do Marcos: que diversas pessoas consideram métodos privados como um &lt;a href=&quot;http://www.pedromendes.com.br/2013/11/04/code-smells/&quot;&gt;&lt;em&gt;Code Smell&lt;/em&gt; (algo como “mau-cheiro de código”)&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Como eu nunca tinha ouvido ou lido nada nesse sentido antes, fiquei bastante surpreso e decidi pesquisar mais.&lt;/p&gt;

&lt;h2 id=&quot;qual-seria-o-problema-de-mtodos-privados&quot;&gt;Qual seria o problema de métodos privados?&lt;/h2&gt;

&lt;p&gt;Para começar, vamos tentar entender por qual razão métodos privados seriam um problema.&lt;/p&gt;

&lt;p&gt;One common argument is that private methods violate the Single Responsibility Principle. The SRP states that each class should do only one thing. If you’re tempted to create private methods, the argument follows, that’s a sign that your class is doing too much.&lt;/p&gt;

&lt;p&gt;Um argumento comum é que métodos privados violam o &lt;em&gt;Princípio da Responsabilidade Única&lt;/em&gt; (ou SRP, do inglês &lt;em&gt;Single Responsibility Principle&lt;/em&gt;).&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Private helper methods indicate classes are doing too many things. Moving private helper methods to different classes, including creating new classes if necessary, splits the original responsibilities across multiple classes leading to simpler, better designs.&lt;/p&gt;

  &lt;p&gt;Kent R Spillner, em &lt;a href=&quot;http://kent.spillner.org/blog/work/2009/11/12/private-methods-stink.html&quot;&gt;Private Methods are a Code Smell&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Em tradução livre:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Métodos auxiliares privados indicam que as classes estão fazendo coisas demais. Mover métodos auxiliares privados para classes diferentes, incluindo criar novas classes se necessário, divide as responsabilidades originais em múltiplas classes, levando à projetos mais simples e melhores.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Aqui temos uma opinião bem parecida:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Private methods are not inherently bad, but they are a sign that you might be missing out on an opportunity to make a useful abstraction. If you have a private method that calls another private method, then there is almost certainly an area of responsibility that remains unidentified.&lt;/p&gt;

  &lt;p&gt;John McDowall, em &lt;a href=&quot;http://blog.stormid.com/2015/03/method-access-modifiers-as-code-smells/&quot;&gt;Break. It. Up! – Private Method Access Modifiers as Code Smells&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Em tradução livre:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Métodos privados não são inerentemente ruins, mas eles são um sinal de que você talvez esteja perdendo uma oportunidade de criar uma abstração útil. Se você tem um método privado que chama outro método privado, então é quase certeza que há uma outra área de responsabilidade que permanece não identificada.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Outro argumento é que métodos privados dificultam o uso de testes unitários:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Make it public!&lt;/p&gt;

  &lt;p&gt;[…]This is probably the simplest way to overcome the problem of untestability.[…] There’s a reason for that:  testability is a perfectly good reason to make something public.  And you should test most of your code.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Jason M Baker, em &lt;a href=&quot;https://jasonmbaker.wordpress.com/2009/01/08/enemies-of-test-driven-development-part-i-encapsulation/&quot;&gt;Enemies of Test Driven Development part I: encapsulation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Em tradução livre:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Torne [o método privado] público!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;[…]Essa é provavelmente a maneira mais simples de resolver o problema da não-testabilidade[…] Existe uma razão para isso: testabilidade é uma razão perfeitamente boa para tornar algo público. E você deveria testar a maior parte do seu código.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Finalmente, pessoas também argumentam que métodos privados desempenham um papel importante no problema de “bagunçar” o estado interno dos objetos, o que pode lhe causar grandes problemas.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Functional programming teaches that state (in the form of member variables) is evil, because it makes your code more complex and harder to test.&lt;/p&gt;

  &lt;p&gt;Ryan Ginstrom, em &lt;a href=&quot;http://ginstrom.com/scribbles/2007/11/12/three-reasons-to-avoid-private-class-members/&quot;&gt;Three reasons to avoid private class members&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Em tradução livre:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Programação funcional ensina que estado (na forma de variáveis de instância) é maligno, porque ele torna seu código mais complexo e mais difícil de ser testado.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Eu acabei de mostrar alguns dos argumentos comuns contra a criação de métodos privados, então agora é hora de mostrar a opinião nesse assunto.&lt;/p&gt;

&lt;h2 id=&quot;mtodos-privados-no-so-necessariamente-violaes-do-srp&quot;&gt;Métodos privados &lt;em&gt;não&lt;/em&gt; são necessariamente violações do SRP&lt;/h2&gt;

&lt;p&gt;O primeiro argumento apresentando afirma que métodos privados violam o Princípio da Responsabilidade Única.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;Private helper methods indicate classes are doing too many things.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Eu não penso que esse seja o caso. Pelo menos, não sempre. Isso depende do que exatamente o método privado faz.&lt;/p&gt;

&lt;p&gt;Você provavelmente não deveria adicionar um método chamado &lt;code class=&quot;highlighter-rouge&quot;&gt;ValidarEnderecoDeEmail&lt;/code&gt; à sua classe &lt;code class=&quot;highlighter-rouge&quot;&gt;Cliente&lt;/code&gt;, sendo o método privado ou não. Afinal de contas, um cliente não é a única entidade que pode ter um endereço de e-mail. Ao invés disso, crie uma classe &lt;code class=&quot;highlighter-rouge&quot;&gt;Email&lt;/code&gt; e coloque todas as validações pertinentes nela.&lt;/p&gt;

&lt;p&gt;Por outro lado, digamos que você esteja criando um método &lt;code class=&quot;highlighter-rouge&quot;&gt;Ordenar&lt;/code&gt; em uma estrutura de dados customizada. Nesse caso, faria todo o sentido manter o método &lt;code class=&quot;highlighter-rouge&quot;&gt;Ordenar&lt;/code&gt; público, e ter alguns métodos privados auxiliares, como &lt;code class=&quot;highlighter-rouge&quot;&gt;CompararItens&lt;/code&gt; e &lt;code class=&quot;highlighter-rouge&quot;&gt;Trocar&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;Moving private helper methods to different classes, including creating new classes if necessary, splits the original responsibilities across multiple classes leading to simpler, better designs.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Meu principal problema com esse argumento não é que classes pequenas são geralmente melhores que as grandes, o que eu concordo.&lt;/p&gt;

&lt;p&gt;Meu problema é que eu não concordo que criar novas classes e métodos públicos &lt;strong&gt;apenas para evitar métodos privados&lt;/strong&gt; vai &lt;strong&gt;automaticamente&lt;/strong&gt; gerar “designs mais simples e melhores”. É claro que &lt;em&gt;pode&lt;/em&gt; gerar; mas pode gerar projetos priores também. Cada situação é única.&lt;/p&gt;

&lt;h2 id=&quot;eu-no-compro-testabilidade-como-um-fim-em-si-mesmo&quot;&gt;Eu não compro testabilidade como um fim em si mesmo&lt;/h2&gt;

&lt;p&gt;Eu gosto muito de testes unitários (e testes automatizados de uma maneira geral). Eu ajudei evangelizar testes unitários no meu trabalho, e atualmente eu supervisiono o time que está adicionando testes unitários e de integração em nosso &lt;em&gt;codebase&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;E uma das primeiras perguntas que as pessoas fazem quando estão aprendendo sobre testes unitários é: &lt;em&gt;Como eu faço para testar métodos privados?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;unicorn_dies.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Minha resposta geralmente é: &lt;strong&gt;você não deveria precisar&lt;/strong&gt;. Na minha opinião, não é muito produtivo colocar um esforço excessivo em testar métodos privados: como eles são chamados pelos públicos, eles vão ser exercitados pela sua suíte de testes de qualquer forma.&lt;/p&gt;

&lt;p&gt;O objetivo de um teste unitário deveria ser testar e documentar uma “unidade” (uma classe) por meio de usar sua API pública. O que nos leva ao próximo ponto.&lt;/p&gt;

&lt;h1 id=&quot;sua-api-pblica-deve-ser-estvel-ou-encapsulamento-importa&quot;&gt;Sua API pública deve ser estável (ou “Encapsulamento importa”)&lt;/h1&gt;

&lt;p&gt;API significa &lt;em&gt;Application Programming Interface&lt;/em&gt;, ou Interface de Programação de Aplicações, em tradução livre. 
Esse termo pode significar várias coisas, mas no nosso contexto aqui, pense no conjunto das classes e métodos públicos que você expõe aos consumidores.&lt;/p&gt;

&lt;p&gt;A API age como um tipo de contrato entre você e os consumidores do seu código. É um acordo. Se você alterar o acordo, a outra parte não vai ficar muito feliz.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;deal.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Sua API pública deveria ter o máximo de estabilidade possível. Isso é particularmente importante quando você está criando um &lt;em&gt;web service&lt;/em&gt;, uma biblioteca, ou qualquer tipo de ferramenta na qual terceiros dependem.&lt;/p&gt;

&lt;p&gt;A propósito, esses “terceiros” não necessariamente precisar estar distante geograficamente de você. É bem comum em empresas, médias para cima, que vários times dependam de código disponibilizado por outros. O que aconteceria se cada equipe fizesse alterações drásticas em suas APIs constantemente? Caos.&lt;/p&gt;

&lt;p&gt;A partir do momento que você expõe um método publicamente, você tem a responsabilidade de mantê-lo funcionando e honrando seu contrato; do contrário, você corre o risco de causar quebra de retrocompatibilidade nos seus clientes!&lt;/p&gt;

&lt;p&gt;Um bom uso de métodos privados pode ajudar a manter um encapsulamento correto no seu design.&lt;/p&gt;

&lt;p&gt;Aqui temos mais uma citação de Kent R Spillner:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Sometimes, private methods are created just to give pieces of functionality more descriptive names. Although descriptive names are desirable, creating private methods to provide descriptive names for things is still a smell. Moving these methods to collaborators and making them public creates opportunities for future reuse without reducing the clarity of the original code.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Em tradução livre:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Às vezes, métodos privados são criados apenas para dar nomes mais descritivos a pequenos trechos de funcionalidade. Embora nomes descritivos são desejáveis, criar métodos privados para dar nomes descritivos a coisas ainda é um &lt;em&gt;smell&lt;/em&gt;. Mover esses métodos para colaboradores e torná-los públicos cria oportunidades para reuso futuro sem reduzir a claridade do código original.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Esse é um dos pontos com os quais eu discordo mais veementemente. Eu frequentemente crio métodos privados pela exata razão que Kent critica aqui, ou seja, dar nomes descritivos a certos trechos de código, um hábito eu adquiri após ler o livro &lt;em&gt;Código Limpo&lt;/em&gt;, de Robert C. Martin.&lt;/p&gt;

&lt;p&gt;Kent defende que o jeito correto de lidar com isso seria mover esses métodos para novas classes e torná-los públicos.&lt;/p&gt;

&lt;p&gt;Mas se eu fizer isso, eu adiciono um novo método à API público da minha aplicação! Agora eu tenho um método a mais para documentar, testar e manter, mesmo que jamais tenha intencionado que esse método fizesse parte da API.&lt;/p&gt;

&lt;p&gt;Aqui temos uma definição para modificadores de acesso que na minha opinião acerta em cheio:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;public - this method is part of the published API and will not change within major versions of the class&lt;/p&gt;

  &lt;p&gt;[…]&lt;/p&gt;

  &lt;p&gt;private - this method was refactored out of a well tested public or protected method for reasons of clarity or internal re-use. This method may absolutely change, even in patch releases, and should not be relied upon to even exist.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Em tradução livre:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;público - este método é parte da API publicada e não vai mudar dentro de versões principais da classe.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;[…]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;privado - este método foi criado na refatoração de um método público ou protegido bem testado, por razões de claridade ou reuso interno. Este método com certeza pode ser alterado, mesmo em releases de correção, e ninguém deveria depender da existência dele.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Eu concordo com essa definição. Portanto, em minha visão.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Métodos privados não são necessariamente uma coisa ruim a ser evitada a todo custo.&lt;/li&gt;
  &lt;li&gt;A prática de tornar métodos privados em públicos não leva automaticamente a um design melhor; ela pode também gerar uma API desnecessariamente inflada, encapsulamento enfraquecido, e maior trabalho para manutenção.&lt;/li&gt;
  &lt;li&gt;Testabilidade é um objetivo nobre, mas precisa ser buscado de maneira pragmática. Métodos públicos bem testados e bem documentados deveriam ser suficientes, na maioria dos casos.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;mtodos-privados-podem-ser-bons-ou-ruins-aprenda-a-separ-o-joio-do-trigo&quot;&gt;Métodos privados podem ser bons ou ruins; aprenda a separ o joio do trigo&lt;/h2&gt;

&lt;p&gt;Tudo isso dito, eu também acho que existem casos nos quais métodos privados são usados de uma maneira errada. Toda ferramenta pode ser abusada. Existem alguns sinais para os quais você precisa ficar alerta:&lt;/p&gt;

&lt;p&gt;Se um método privado está em um &lt;strong&gt;nível de abstração diferente&lt;/strong&gt; que os públicos em uma classe, é um sinal de que ele pertence em outra classe. Leitura e escrita em arquivo está um nível de abstração bem mais baixo que o cálculo do pagamento mensal de um empregado, por exemplo.&lt;/p&gt;

&lt;p&gt;Quando um método privado é tão complexo que você realmente queria poder testá-lo…é sinal de que ele provavelmente deveria ser público. (Antes que você corra para os comentários para apontar minha aparente contradição, eu não estou dizendo que &lt;strong&gt;todos&lt;/strong&gt; os métodos privados deveriam virar públicos para serem testáveis…apenas aqueles que ultrapassam um determinado limiar de complexidade).&lt;/p&gt;

&lt;blockquote class=&quot;twitter-tweet&quot; data-lang=&quot;pt&quot;&gt;&lt;p lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;&lt;a href=&quot;https://twitter.com/pablogl&quot;&gt;@pablogl&lt;/a&gt; i only test public methods. if a private method is complex enough to need testing, it generally needs its own object.&lt;/p&gt;&amp;mdash; Kent Beck (@KentBeck) &lt;a href=&quot;https://twitter.com/KentBeck/status/3579860805&quot;&gt;27 de agosto de 2009&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async=&quot;&quot; src=&quot;//platform.twitter.com/widgets.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;

&lt;p&gt;E quando um método privado contém código duplicado, do tipo, copiado e colado de outra classe? Livre-se da duplicação na hora!&lt;/p&gt;

&lt;p&gt;Então, esse é o ponto: duas das três dicas que acabo de mostrar são meio subjetivas. Em algum ponto, você tem que fazer algumas escolhas. Quão complexo é complexo o suficiente para um método privado precisar de testes unitários? Como distinguir níveis de abstrações diferentes?&lt;/p&gt;

&lt;p&gt;A melhor dica que eu posso oferecer é: &lt;strong&gt;Duas cabeças pensam melhor que uma&lt;/strong&gt;. Sempre faça com que outra pessoa olhe e examine seu código antes de ser commitado. Programação em par e/ou revisão de código são ótimas técnicas, não apenas para melhorar o projeto e encontrar bugs, mas principalmente para espalhar conhecimento por uma equipe. Não só conhecimento técnico, mas conhecimento do domínio também, e isso pode fazer toda a diferença na hora de tomar as decisões difíceis.&lt;/p&gt;

&lt;h2 id=&quot;concluso&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Embora métodos privados podem ser usados em maneiras ruins, eu penso que seria prematuro automaticamente rotulá-los como uma coisa ruim a ser evitada.&lt;/p&gt;

&lt;p&gt;Me parece que algumas das pessoas que afirmam estar argumentando contra métodos privados &lt;strong&gt;estão na verdade argumento contra problemas que são ortogonais a métodos privados&lt;/strong&gt;; você pode violar a SRP com ou sem métodos privados; você pode causar problemas com estado interno mutável com ou sem métodos privados, e assim por diante.&lt;/p&gt;

&lt;p&gt;Desenvolver software é uma arte, cheia de &lt;em&gt;trade-offs&lt;/em&gt; e incerteza. E ainda que “regras de ouro” possam ser úteis, elas não devem ser seguidas cegamente.&lt;/p&gt;

&lt;p&gt;Este post ficou muito mais longo do que eu planejei. Agradeço caso tenha chegado até aqui. Até a próxima!&lt;/p&gt;

&lt;h2 id=&quot;veja-tambm&quot;&gt;Veja também&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/2620699/why-private-methods-in-the-object-oriented&quot;&gt;http://stackoverflow.com/questions/2620699/why-private-methods-in-the-object-oriented&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://kent.spillner.org/blog/work/2009/11/12/private-methods-stink.html&quot;&gt;http://kent.spillner.org/blog/work/2009/11/12/private-methods-stink.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.stormid.com/2015/03/method-access-modifiers-as-code-smells/&quot;&gt;http://blog.stormid.com/2015/03/method-access-modifiers-as-code-smells/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://jasonmbaker.wordpress.com/2009/01/08/enemies-of-test-driven-development-part-i-encapsulation/&quot;&gt;https://jasonmbaker.wordpress.com/2009/01/08/enemies-of-test-driven-development-part-i-encapsulation/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/i-m-h-o/private-methods-smelly-ish-435e93ff8c39#.cl06rkgct&quot;&gt;https://medium.com/i-m-h-o/private-methods-smelly-ish-435e93ff8c39#.cl06rkgct&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://ginstrom.com/scribbles/2007/11/12/three-reasons-to-avoid-private-class-members/&quot;&gt;http://ginstrom.com/scribbles/2007/11/12/three-reasons-to-avoid-private-class-members/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://rc3.org/2010/01/26/the-argument-against-private-methods/&quot;&gt;http://rc3.org/2010/01/26/the-argument-against-private-methods/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://naildrivin5.com/blog/2010/05/26/is-private-a-code-smell.html&quot;&gt;http://naildrivin5.com/blog/2010/05/26/is-private-a-code-smell.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 29 Jan 2017 00:00:00 -0200</pubDate>
        <link>http://carlosschults.net/pt/metodos-privados-code-smell/</link>
        <guid isPermaLink="true">http://carlosschults.net/pt/metodos-privados-code-smell/</guid>
        
        <category>code smell</category>
        
        <category>boas práticas</category>
        
        <category>orientacao-a-objetos</category>
        
        
      </item>
    
      <item>
        <title>Resenha de Livro: Soft Skills</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://res.cloudinary.com/dz5ppacuo/image/upload/v1469301144/soft-skills-1038-437-min_u6ucwf.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Que tal um livro de desenvolvimento de software que não é sobre software?
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;Vários meses se passaram desde que eu &lt;a href=&quot;http://carlosschults.net/pt/resenha-livro-programador-pragmatico/&quot;&gt;publiquei minha resenha do livro “O Programador Pragmático”, de Andy Hunt e Dave Thomas&lt;/a&gt;. Ou seja, já está mais do que na hora de outro review.&lt;/p&gt;

&lt;p&gt;O livro de hoje é &lt;em&gt;Soft Skills: The software developer’s life manual&lt;/em&gt;, por John Sonmez. Até onde eu sei, não foi traduzido ainda para o português. Se eu estiver errado, me corrijam aí nos comentários.&lt;/p&gt;

&lt;p&gt;John Sonmez é um desenvolvedor de software mais conhecido por seu blog &lt;em&gt;Simple Programmer&lt;/em&gt; e seu canal no youtube. Nessas plataformas, ele cria e publica conteúdo em uma variedade de tópicos, como finanças, negociação, técnicas de aprendizado, exercícios físicos, empreendedorismo, e por aí vai.&lt;/p&gt;

&lt;p&gt;Pense algo do tipo “auto-ajuda para desenvolvedores de software”, mas sem a conotação negativa que auto-ajuda geralmente tem.&lt;/p&gt;

&lt;h2 id=&quot;certo-mas-e-o-livro&quot;&gt;Certo, mas e o livro?&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Soft Skills: The software developer’s life manual&lt;/em&gt; foi publicado no final de 2014, e contém prefácios de &lt;a href=&quot;http://www.hanselman.com/&quot;&gt;Scott Hanselman&lt;/a&gt; e &lt;a href=&quot;https://twitter.com/unclebobmartin&quot;&gt;Robert C. Martin&lt;/a&gt;, o famoso “Uncle Bob”.&lt;/p&gt;

&lt;p&gt;As its name suggests, this book doesn’t cover any tech-related topics, at least not in a direct way. It is divided into seven sections: Career, Marketing Yourself, Learning, Productivity, Financial, Fitness, Spirit. Each section is meant to cover a specific area of a software developer’s life, and is divided into several short chapters.&lt;/p&gt;

&lt;p&gt;Como o nome sugere, o livro não cobre assuntos técnicos, pelo menos não diretamente. Ele é dividido em sete seções: Carreira, Marketing Pessoal, Aprendizado, Produtividade, Finanças, Fitness, Espírito. Cada seção por sua vez é divida em vários capítulos curtos.&lt;/p&gt;

&lt;p&gt;O livro em si é até grande - a edição que eu possuo tem 470 páginas. Levei um bom tempo pra terminar, embora eu admito que li o livro em um ritmo mais lento do que de costume.&lt;/p&gt;

&lt;h2 id=&quot;the-good&quot;&gt;The Good&lt;/h2&gt;

&lt;p&gt;O livro é escrito em um estilo bem fácil de entender e seguir. Mesmo lendo no original em inglês, não tive nenhuma dificuldade em acompanhar.&lt;/p&gt;

&lt;p&gt;Os capítulos são curtos, o que para mim é uma boa coisa. Geralmente eu não disponho de um intervalo grande de tempo para ler. O que eu consigo são vários intervalos pequenos ao longo do dia. Então é ótimo quando os capítulos são curtos o bastante para caber nesses intervalos. Eu não tenho muita certeza do porquê, mas acho estranho deixar um capítulo sem terminar, então eu fico um pouco incomodado se começo a ler um capítulo sabendo que provavelmente não conseguirei terminá-lo na mesma sessão.&lt;/p&gt;

&lt;p&gt;Cada capítulo de &lt;em&gt;Soft Skills&lt;/em&gt; termina com uma “chamada à ação”. John lhe convida a fazer um pequeno exercício para ajudá-lo a tirar o maior proveito do conteúdo, e descobrir a melhor forma de aplicá-lo em sua vida. Não se assuste com a palavra “exercício”. Os desafios propostos são todos muito fáceis de seguir e geralmente envolvem um pouco de reflexão e depois alguma escrita. Eu geralmente sou o tipo de pessoa que iria chamar isso de “bobagem de autoajuda”. Mas o que eu descobrir ao ler este livro é que isso pode ser realmente eficaz.&lt;/p&gt;

&lt;p&gt;A questão é: você pode pensar que sabe o que quer fazer com a sua carreira e com a sua vida. Mas quando você se força a parar por alguns minutos e realmente pensar sobre isso e escrever em um pedaço de papel…você pode se surpreender com o quão pouco você realmente sabe sobre suas metas, suas forças, suas fraquezas, e o que você pretende realizar na vida.&lt;/p&gt;

&lt;p&gt;Isso é particularmente verdadeiro no começo da sua carreira. Nossa área é gigantesca. Quando você é recém-graduado, jovem e sem experiência, só a quantidade de opções disponíveis já é suficiente para lhe deixar sobrecarregado. É melhor arrumar emprego em uma start-up ou uma empresa grande? Talvez ser freelancer? Ruby on Rails ou Node.ks? Tantas dúvidas!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Soft Skills&lt;/em&gt; oferece alguma ajuda aqui. A primeira seção do livro sobre, entre outras coisas:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;opções de emprego (freelancer x empregado x empreendedor);&lt;/li&gt;
  &lt;li&gt;tipos de especialidades para desenvolvedores;&lt;/li&gt;
  &lt;li&gt;tipos de empresas para se trabalhar;&lt;/li&gt;
  &lt;li&gt;conselhos para trabalhar remotamente.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Seção 4 (Produtividade) é talvez a minha favorita. A verdade é essa: se me deixar por conta própria, eu não sou lá tão produtivo. Shame on me!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://res.cloudinary.com/dz5ppacuo/image/upload/v1470788220/shame_mivvrv.gif&quot; alt=&quot;Entendedores entenderão.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Eu venho brigando com a procrastinação desde a faculdade. Já tentei vários aplicativos de lista de tarefas e técnicas de produtividade. Eu leio &lt;a href=&quot;https://www.amazon.com/Getting-Things-Done-Stress-Free-Productivity-ebook/dp/B000WH7PKY#navbar&quot;&gt;Getting Things Done&lt;/a&gt; todo ano. Eu leio &lt;a href=&quot;http://lifehacker.com/&quot;&gt;Lifehacker&lt;/a&gt; quase que diariamente. Eu inclusive ouço um &lt;a href=&quot;https://www.relay.fm/cortex&quot;&gt;podcast cujo principal tema é trabalho e produtividade&lt;/a&gt;. E mesmo assim, eu não sou tão produtivo como eu gostaria de ser, apesar de que tenho feito algum progresso.&lt;/p&gt;

&lt;p&gt;Aqueles dentre vocês que compartilham dessa característica vão provavelmente encontrar algum valor em &lt;em&gt;Soft Skills&lt;/em&gt;. John cobre bastante coisa aqui, incluindo a formação de hábitos, a importância de se ter uma rotina, e quais são os maiores desperdícios de tempo que você deveria tentar eliminar da sua vida. Ele também fala sobre a 
&lt;a href=&quot;https://en.wikipedia.org/wiki/Pomodoro_Technique&quot;&gt;Técnica Pomodor&lt;/a&gt; e demonstra seu sistema de produtividade pessoal. Ele fala até sobre &lt;em&gt;burnout&lt;/em&gt;, o que pode ser um grande problema na nossa área e você definitivamente deve estar preparado(a) para lidar com isso durante sua carreira.&lt;/p&gt;

&lt;p&gt;Uma crítica comum que o livro recebe - e algumas pessoas estendem essa crítica ao restante do trabalho de John - é que ele é muito voltado para o marketing. É uma afirmação até justa, eu diria. Mas eu não penso que isso é necessariamente uma coisa ruim.&lt;/p&gt;

&lt;p&gt;Alguns anos atrás, na faculdade, eu assisti uma palestra na qual o palestrante disse algo do tipo: “não adianta nada você ser o melhor programador do mundo se ninguém sabe disso”.&lt;/p&gt;

&lt;p&gt;Para muitos desenvolvedores, a palavra marketing tem uma conotação muito negativa. Também pudera, todos estamos cansados de ver táticas de marketing manipulativas e sem escrúpulo.
O que precisa ser entendido aqui é que marketing é algo que nós todos fazemos, o tempo todo, mesmo que você não chame por esse nome. O que é uma entrevista de emprego, senão uma venda?&lt;/p&gt;

&lt;p&gt;Já que marketing é algo que todos fazemos, vale a pena fazê-lo correta e deliberadamente. Aqui é o ponto forte do livro, na minha opinião. Ele oferece conselhos sobe como tratar sua carreira como um negócio e seu nome como uma marca. Ele também explica o que uma marca é, qual seu propósito, seus componentes, e como você pode &lt;strong&gt;criar e estabelecer sua marca pessoal gerando valor para outras pessoas&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;As seções 3 e 6 (&lt;em&gt;Aprendizado&lt;/em&gt; e &lt;em&gt;Fitness&lt;/em&gt;, respectivamente) também merecem menção honrosa, mas não as cobrirei em detalhe para não ficar muito extenso. Vai ler o livro! :D&lt;/p&gt;

&lt;h2 id=&quot;the-bad&quot;&gt;The Bad&lt;/h2&gt;

&lt;p&gt;Agora, vamos ver o que não é tão bom assim.&lt;/p&gt;

&lt;p&gt;Alguns dos capítulos são muito, muito curtos. Sim, eu sei que poucos parágrafos atrás eu estava elogiando a brevidade dos capítulos. Por que estou falando o contrário agora?&lt;/p&gt;

&lt;p&gt;Eu não me importo com um capítulo curto caso ele me dê algum valor. Na verdade, como eu disse antes, eu prefiro muito mais um capítulo curto a um maior, desde que ambos forneçam igual valor.&lt;/p&gt;

&lt;p&gt;Mas alguns capítulos fornecem pouquíssimo valor. Eles poderiam tranquilamente ser um parágrafo em outra seção.&lt;/p&gt;

&lt;p&gt;Por exemplo. Capítulo 18, “Não seja religioso sobre tecnologia”, tem três páginas, nas quais John nos diz para que não nos apegarmos exageradamente a linguagens de programação, frameworks, sistemas operacionais e etc. Ótimo conselho, concordo totalmente. Quantas horas já foram desperdiçadas na internet, em debates idiotas como “tabs x espaços”? Provavelmente bem mais do que gostaríamos de saber. Mas essa mensagem seria facilmente resumida em um parágrafo em outro capítulo.&lt;/p&gt;

&lt;p&gt;O livro também sofre do problema oposto. Alguns assuntos provavelmente se beneficiariam de um pouco mais de profundidade. No capítulo 25, “Escrevendo livros e artigos para atrair seguidores”, John diz que para conseguir publicar um livro por meios tradicionais, você deveria escrever uma proposta, para tentar vender o livro para a editora. Mas ele para por aí, &lt;strong&gt;sem mostrar um exemplo de como tal proposta seria&lt;/strong&gt;, o que seria extremamente valioso para os potenciais autores em sua audiência.&lt;/p&gt;

&lt;p&gt;Algumas das dicas do livro são…esquisitas. Eu particularmente não gostei do conselho de John para contratar um escritor de currículo profissional. Na nossa área, hoje em dia, currículos são pouca coisa mais que mera formalidade. Contanto que seu currículo não seja horrível (ie.e contém erros de grafia e gramática, está estruturado de uma maneira estranha, não contém informações essenciais, etc) provavelmente vai ficar tudo bem. Existem fatores muito mais importantes que seu potencial empregador vai levar em consideração.&lt;/p&gt;

&lt;h2 id=&quot;the-ugly&quot;&gt;The Ugly&lt;/h2&gt;

&lt;p&gt;A maioria dos livros de software tem a capa feia ou estranha, e &lt;strong&gt;&lt;em&gt;Soft Skills&lt;/em&gt;&lt;/strong&gt; não é exceção. Mas quem liga? Eu só queria &lt;a href=&quot;https://en.wikipedia.org/wiki/The_Good,_the_Bad_and_the_Ugly&quot;&gt;fazer essa referência mesmo :P&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;concluso&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Soft Skills: The software developer’s life manual&lt;/em&gt; foi uma leitura divertida. John oferece algumas ótimas dicas, especialmente no que diz respeito a aprendizado, carreira e produtividade.&lt;/p&gt;

&lt;p&gt;Existem alguns contras, claro, como eu já disso. Algumas das dicas simplesmente não fazem sentido pra mim. Eu entendo que elas provavelmente funcionaram para o autor, entretanto.&lt;/p&gt;

&lt;p&gt;Minha abordagem com esse tipo de livro é: guarde o que for valioso, ignore o resto. E eu posso tranquilamente dizer que encontrei uma boa quantidade de conteúdo valioso em &lt;em&gt;Soft Skills&lt;/em&gt;.&lt;/p&gt;
</description>
        <pubDate>Tue, 09 Aug 2016 00:00:00 -0300</pubDate>
        <link>http://carlosschults.net/pt/resenha-livro-soft-skills/</link>
        <guid isPermaLink="true">http://carlosschults.net/pt/resenha-livro-soft-skills/</guid>
        
        <category>livros</category>
        
        
      </item>
    
      <item>
        <title>Tipos de valor e referência em C#, Parte 2 - Por que DateTime não pode ser nulo?</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://res.cloudinary.com/dz5ppacuo/image/upload/v1466341001/csharp-min_buiizq.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;“Por que uma variável DateTime não pode receber &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;?” Esta é uma pergunta que vive aparecendo no &lt;em&gt;StackOverflow&lt;/em&gt; e site similares. Às vezes escrita de modo um pouco diferente, às vezes com um tipo diferente, mas no fundo é a mesma dúvida. O que é natural, se você considerar que provavelmente milhares de pessoas entram na área a cada ano.
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;A resposta curta é: porque DateTime/int/float/etc é um &lt;strong&gt;tipo de valor&lt;/strong&gt;, e tipos de valor não podem nunca receber &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;. Apenas tipos de referência podem.&lt;/p&gt;

&lt;p&gt;Legal, mas…por quê?&lt;/p&gt;

&lt;p&gt;Em algum momento os projetistas do C# tiveram que tomar essa decisão. Eles deliberadamente decidiram que tipos de valor não poderiam receber &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;. Será que tem alguma coisa que naturalmente impede isso? Talvez tenha algo a ver com a pilha e a heap?&lt;/p&gt;

&lt;p&gt;Eu acho que antes de tentarmos responder essas questões, seria interessar voltar um passo e pensar um pouco sobre outra questão.&lt;/p&gt;

&lt;h2 id=&quot;o-que-exatamente--null&quot;&gt;O que exatamente é null?&lt;/h2&gt;

&lt;p&gt;Você provavelmente pensa em &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt; como uma maneira de representar uma informação que está faltando. Algo desconhecido, ausente ou irrelevante. Talvez um dado que não está onde deveria &lt;em&gt;ainda&lt;/em&gt;, mas talvez esteja no futuro.&lt;/p&gt;

&lt;p&gt;Lembra do meu &lt;a href=&quot;http://carlosschults.net/pt/tipos-valor-referencia-em-csharp/&quot;&gt;post anterior sobre tipos de valor e referência&lt;/a&gt;? Nele nós vimos que uma variável de um tipo de referência &lt;strong&gt;contém uma referência que aponta para uma instância daquele tipo específico&lt;/strong&gt;. Mas quando a variável recebe &lt;em&gt;null&lt;/em&gt;, seu conteúdo passa a ser o quê? Nada?&lt;/p&gt;

&lt;p&gt;Não exatamente. Ainda que &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt; essencialmente signifique nada, esse “nada” precisa ser representado de alguma forma na memória do computador.&lt;/p&gt;

&lt;p&gt;No C#, a palavra reservada &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt; representa uma &lt;strong&gt;referência nula&lt;/strong&gt;, que é uma referência que não aponta para nenhum objeto. Na prática, essa referência é representada como um número (de 32 ou 64 bits, dependendo do sistema operacional) com todos os bits zerados.&lt;/p&gt;

&lt;p&gt;É claro, tudo isso são detalhes de implementação. Isso poderia ter sido implementado de maneiras diferentes, ou seja, não é tão relevante assim pra gente agora. O que você realmente precisa entender é que você &lt;strong&gt;precisa de algo para representar nada&lt;/strong&gt;. É necessário algum tipo de valor especial que significa “esse valor está faltando” ou “esse valor é desconhecido”.&lt;/p&gt;

&lt;p&gt;Quando você entende isso, fica mais fácil enxergar qual é o problema com tipos de valor.&lt;/p&gt;

&lt;h2 id=&quot;como-voc-representaria-null-para-um-tipo-de-valor&quot;&gt;Como você representaria null para um tipo de valor?&lt;/h2&gt;

&lt;p&gt;Para entender qual é a dificuldade em fazer um tipo de valor ser nulo, você precisa considerar que tipos de valor geralmente têm um intervalo de valores possíveis que eles são capazes de representar.&lt;/p&gt;

&lt;p&gt;É mais fácil de entender isso com um exemplo. Então, considere o tipo de valor &lt;a href=&quot;https://msdn.microsoft.com/pt-br/library/system.byte(v=vs.110).aspx&quot;&gt;byte&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Esse tipo representa um número inteiro sem sinal de 8 bits. Como 2 elevado a 8 é 256, é possível representar 256 valores. Como é um tipo “sem sinal”, ele só pode representar valores maiores ou igual a zero. Portanto, o range de valores possíveis para esse tipo é &lt;strong&gt;de 0 a 255&lt;/strong&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;00000000 =&amp;gt; 0
00000001 =&amp;gt; 1
00000010 =&amp;gt; 2
    .        .
    .        .
    .        .
11111111 =&amp;gt; 255
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Agora vem a parte complicada. Se os projetistas do C# quisessem que o tipo byte fosse nulável, eles teriam que escolher um dos valores desse intervalo para elegê-lo como o valor nulo. Imagine que eles tivessem escolhido o zero. Nesse caso, &lt;strong&gt;nós nunca poderíamos usar o zero como um valor válido novamente!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Esse é todo o problema: para que um tipo de valor seja nulável, seria necessário sacrificar um dos possíveis valores do intervalo para representar o valor nulo.&lt;/p&gt;

&lt;p&gt;Jon Skeet, autor do livro C# In Depth, é capaz de explicar bem melhor do que eu:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;You’ve got to be able to store the values 0-255 in that variable; otherwise it’s useless for reading arbitrary binary data. With the 256 normal values
and one null value, you’d have to cope with a total of 257 values, and there’s no way of squeezing that many values into a single byte.&lt;/p&gt;

  &lt;p&gt;The designers could’ve decided that every value type would have an extra flag bit somewhere determining whether a value was null or contained real data, but the memory usage implications 
are horrible, not to mention the fact that you’d have to check the flag every time you wanted the use the value.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Em tradução livre:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Você precisa ser capaz de armazenar os valores de 0 a 255 naquela variável; do contrário esse tipo seria inútil para ler dados binários arbitrários. Com os 256 valores normais e um valor nulo, você teria que lidar com um total de 257 valores, e não tem jeito de espremer tudo isso em um único byte.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Os projetistas poderiam ter decidido que todo tipo de valor teria um bit extra em algum lugar determinando se um valor é nulo ou contém dados reais, mas as implicações de uso de memória são horríveis, sem falar que você teria que checar esse bit toda vez que quisesse usar o valor.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Então, não há nada &lt;strong&gt;em princípio&lt;/strong&gt; que impede que tipos de valor recebem nulo. É que seria tão complicado que os projetistas da linguagem decidiram que os benefícios de fazer isso não superam os custos.&lt;/p&gt;

&lt;h2 id=&quot;mas-eu-realmente-preciso-de-um-tipo-de-valor-nulvel-e-agora&quot;&gt;Mas eu realmente preciso de um tipo de valor nulável. E agora?&lt;/h2&gt;

&lt;p&gt;Agora você entende as complicações envolvidas em representar &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt; para um tipo de valor, e porque os projetistas do C# decidiram contra permitir isso. Mas, e se você realmente precisa fazer isso? Um cenário comum é quando você busca dados de um banco de dados relacional. O que é possível ser feito?&lt;/p&gt;

&lt;p&gt;Felizmente há uma solução fácil. Ainda que tipos de valor “normais” não são nuláveis, a versão 2 do C# introduziu a estrutura &lt;code class=&quot;highlighter-rouge&quot;&gt;Nullable&amp;lt;T&amp;gt;&lt;/code&gt;, que permite atribuir &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt; a praticamente qualquer coisa.&lt;/p&gt;

&lt;p&gt;Falarei sobre isso no próximo artigo da série. Como bônus, você vai aprender um pouco sobre outra feature interessante chamada &lt;strong&gt;generics&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Até lá!&lt;/p&gt;
</description>
        <pubDate>Sun, 19 Jun 2016 00:00:00 -0300</pubDate>
        <link>http://carlosschults.net/pt/tipos-valor-referencia-em-csharp-parte-2/</link>
        <guid isPermaLink="true">http://carlosschults.net/pt/tipos-valor-referencia-em-csharp-parte-2/</guid>
        
        <category>csharp</category>
        
        <category>iniciantes</category>
        
        <category>orientacao-a-objetos</category>
        
        <category>tipagem</category>
        
        
      </item>
    
      <item>
        <title>Dez dicas para lhe ajudar a escolher bons nomes</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://res.cloudinary.com/dz5ppacuo/image/upload/v1462225938/baby-name-min_nosetz.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Só existem duas coisas difíceis em Ciência da Computação: invalidação de cache e escolher nomes das coisas.&lt;/p&gt;

  &lt;p&gt;Phil Karlton&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Você quer escrever um código muito bom? Código limpo, entendível, legível? Existem várias habilidades que você precisa adquirir. Mas eu diria que no topo da lista está “Escolher bons nomes”.
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;Escolher ótimos nomes para suas classes, métodos, variáveis e demais coisas do tipo é essencial. Um nome bem escolhido muitas vezes é a diferença entre código bom e horrível.&lt;/p&gt;

&lt;p&gt;Mas o que é exatamente um bom nome? Apesar de existirem algumas diretrizes bem aceitas, eu devo dizer que não existe exatamente um consenso. (E é assim com muitos tópicos em nossa área, eu diria).&lt;/p&gt;

&lt;p&gt;Então, hoje eu vou falar sobre algumas convenções e princípios que eu uso quando estou codificando. É meio que uma mistura do que eu aprendi na faculdade, estudando por conta própria e trabalhando como um desenvolvedor profissional. Essas convenções e princípios têm sido úteis para mim, então eu espero que sejam úteis para você também.&lt;/p&gt;

&lt;p&gt;Algumas das dicas que vou mostrar vêm do livro “Código Limpo”, escrito por Robert C. Martin (mais conhecido com Uncle Bob). É um dos meus livros de programação favoritos, e eu escreverei uma resenha dele em breve. Fique ligado!&lt;/p&gt;

&lt;h2 id=&quot;use-nomes-auto-explicativos&quot;&gt;0. Use nomes auto-explicativos&lt;/h2&gt;

&lt;p&gt;O quê sua variável/classe/sei-lá-o-quê faz? Como ela deve ser usada? Escolha um nome que responda a essas perguntas.&lt;/p&gt;

&lt;p&gt;Algumas pessoas têm essa ideia esquisita de que nomes mais curtos são sempre melhores. Eu não entendo isso. Elas estão tentando economizar o teclado ou algo assim?&lt;/p&gt;

&lt;p&gt;Digamos que ao ler um código você se depara com isso:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dias&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;para&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fim&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prazo&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Você poderia argumentar que o código está bom assim. O significado da variável está perfeitamento expresso no comentário. Ótimo, mas lembre-se que a variável vai provavelmente ser utilizada em outros pontos, longe da declaração e do comentário.&lt;/p&gt;

&lt;p&gt;Então…não seria melhor se livrar do comentário e usar o texto do comentário como o nome da variável?&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c#&quot; data-lang=&quot;c#&quot;&gt;    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;diasParaFimDoPrazo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h2 id=&quot;use-abreviaes-apenas-quando-elas-so-amplamente-conhecidas&quot;&gt;1. Use abreviações apenas quando elas são amplamente conhecidas&lt;/h2&gt;

&lt;p&gt;Seria loucura nomear uma variável “UniformeResourceLocatorServico” em vez de “UrlServico”. Qualquer desenvolvedor sabe o que uma url é. A mesma coisa com Ftp, UI, IO, e por aí vai. Ou seja, tudo bem usar abreviações nos seus nomes, mas só quando elas são bem conhecidas. Seria contra-produtivo não fazer assim.&lt;/p&gt;

&lt;p&gt;A propósito. Quando eu digo “amplamente conhecidas”, não estou querendo dizer conhecidas no mundo todo, ou mesmo no país todo. É claro que você pode e deve usar abreviações que são comuns no domínio do seu negócio. Em geral é considerado uma boa prática codificar o mais próximo possível da linguagem do cliente. Então, se os outros desenvolvedores e as pessoas de negócio se sentem confortáveis usando as abreviações, não tem problema nenhum utilizá-las.&lt;/p&gt;

&lt;h2 id=&quot;escolha-clareza-ao-invs-de-brevidade&quot;&gt;2. Escolha clareza ao invés de brevidade&lt;/h2&gt;

&lt;p&gt;Isso é parecido com o primeiro ponto. Todo o resto se mantendo igual, nomes mais curtos são melhores. Mas um dia você terá que escolher entre clareza e brevidade. Quando esse dia chegar, escolha a clareza. Seis meses depois, quando você tiver que revisitar aquele código, você vai agradecer a si mesmo.&lt;/p&gt;

&lt;h2 id=&quot;use-convenes-amplamente-aceitas-na-maior-parte-do-tempo&quot;&gt;3. Use convenções amplamente aceitas (na maior parte do tempo&lt;/h2&gt;

&lt;p&gt;Existem poucos pontos no livro “Código Limpo” com os quais eu não concordo. Um deles é a recomendação do Uncle Bob para não começar nomes de interfaces com uma letra “I” maiúscula. Ele argumenta que essa prática é um resquício da Notação Húngara e portanto deveria desaparecer. Mesmo eu entendendo a porque ele pensa dessa forma, vou continuar a nomear minhas interfaces com um “I” no começo.&lt;/p&gt;

&lt;p&gt;Por que? A razão é muito simples: essa é uma convenção bem aceita e utilizada na comunidade .Net. Quando você vai contra uma convenção estabelecida, você corre o risco de alienar desenvolvedores que estão acostumados com essa convenção, como potenciais novos membros da equipe ou contribuidores de projetos open-source.&lt;/p&gt;

&lt;p&gt;A minha opinião é que se deve abandonar uma convenção extremamente bem aceita apenas quando os benefícios de fazer isso são muito maiores que os custos. E eu não acredito que esse seja o caso aqui.&lt;/p&gt;

&lt;h2 id=&quot;no-use-notao-hngara&quot;&gt;4. Não use notação húngara&lt;/h2&gt;

&lt;p&gt;Talvez você tenha ouvido falar de notação húngara, talvez não. Mas eu aposto que você já viu, ou talvez já tenha até mesmo usado, mesmo que o nome não seja familiar.&lt;/p&gt;

&lt;p&gt;Então, o que é essa notação? Nossa amiga Wikipédia veio dar uma mãozinha aqui:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Notação húngara é uma convenção de nomeação de identificadores em programação de computadores, na qual o nome de uma variável ou função indica seu tipo ou uso pretendido.&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Hungarian_notation&quot;&gt;Wikipedia: Hungarian Notation, em tradução livre&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Em resumo, notação húngara é colocar o tipo da variável no seu nome. Se eu tenho uma variável do tipo &lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;, que vou usar pra guardar a idade de um estudante, eu poderia nomeá-la  &lt;code class=&quot;highlighter-rouge&quot;&gt;iIdadeEstudante&lt;/code&gt; ou &lt;code class=&quot;highlighter-rouge&quot;&gt;intIdadeEstudante&lt;/code&gt;. Do mesmo modo, uma variável string que armaze a descrição de um produto poderia ser chamada &lt;code class=&quot;highlighter-rouge&quot;&gt;sDescricaoProduto&lt;/code&gt;, ou até mesmo &lt;code class=&quot;highlighter-rouge&quot;&gt;strDescricaoProduto&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;E por que isso é ruim? Aqui estão algumas razões:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Primeiro, é inútil. Se a sua variável tem um nome auto-explicativo (veja item #0), ela já vai te dar uma boa noção do seu tipo. Se você acha uma variável chamada “nomeProduto”, você acharia que ela é um número de ponto flutuante? Além disso, a maioria das IDEs modernas conseguem te mostrar não apenas o tipo da variável, mas também se ela é uma variável local, membro de instância ou parâmetro de método, e até quantas vezes ele foi referenciada no código da aplicação.&lt;/li&gt;
  &lt;li&gt;Pode causar confusões. Pessoas cometem erros, e é perfeitamente possível mudar o tipo da variável e esquecer de mudar o nome. Então agora você tem uma variável que o nome começa com “int”, mas ela é na verdade um &lt;code class=&quot;highlighter-rouge&quot;&gt;long&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Faz com que os nomes fiquem mais difíceis de pronunciar, e isso pode dificultar discussões sobre o código e a arquitetura da sua aplicação.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;respeite-o-estilo-de-codificao-da-linguagem-framework-ou-projeto&quot;&gt;5. Respeite o estilo de codificação da linguagem, framework, ou projeto&lt;/h2&gt;

&lt;p&gt;Desenvolvedores C# tendem a utilizar &lt;code class=&quot;highlighter-rouge&quot;&gt;CamelCase&lt;/code&gt; para nomear variáveis locais, membros de instância e parâmetros de métodos, como em &lt;code class=&quot;highlighter-rouge&quot;&gt;nomeProduto&lt;/code&gt;. Já em Ruby o estilo recomendado é o &lt;code class=&quot;highlighter-rouge&quot;&gt;snake_case&lt;/code&gt;. A mesma variável ficaria: &lt;code class=&quot;highlighter-rouge&quot;&gt;nome_produto&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Frameworks, bibliotecas e projetos open-source podem ter suas próprias diretrizes e padrões também.&lt;/p&gt;

&lt;p&gt;Seria bobagem lutar contra padrões estabelecidos, por causa do seu próprio gosto e preferência. Se você está desenvolvendo em Ruby, escreva da maneira que a comunidade Ruby espera. O mesmo vale pra Java, C#, PHP, qualquer linguagem/ecossistema.&lt;/p&gt;

&lt;p&gt;É como diz o ditado: “Quando estiver em Roma, faça como os romanos”.&lt;/p&gt;

&lt;h2 id=&quot;nomes-de-mtodos-devem-comear-com-um-verbo&quot;&gt;6. Nomes de métodos devem começar com um verbo&lt;/h2&gt;

&lt;p&gt;Essa dica é bem curta. Métodos são geralmente ações que um objeto pode realizar. Assim, seus nomes deveriam começar com um verbo que indica qual é essa ação, e.g. &lt;code class=&quot;highlighter-rouge&quot;&gt;ImprimirRelatorio()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ExibirPoligono(IPoligono poligono)&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;nomes-de-classes-devem-ser-substantivos&quot;&gt;7. Nomes de classes devem ser substantivos&lt;/h2&gt;

&lt;p&gt;Da mesma forma, nomes de classes deveriam ser substantivos, como &lt;code class=&quot;highlighter-rouge&quot;&gt;Produto&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Cliente&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Estudante&lt;/code&gt;, e assim por diante. Tente evitar termos genéricos como &lt;code class=&quot;highlighter-rouge&quot;&gt;Manager&lt;/code&gt;, porque eles não adicionam nenhum valor.&lt;/p&gt;

&lt;h2 id=&quot;nomes-de-propriedades-devem-ser-substantivos-adjetivos-ou-frases-adjetivas&quot;&gt;8. Nomes de propriedades devem ser substantivos, adjetivos ou frases adjetivas&lt;/h2&gt;

&lt;p&gt;Propriedades devem ser nomeadas com substantivos (&lt;code class=&quot;highlighter-rouge&quot;&gt;Nome&lt;/code&gt;), frases adjetivas ou adjetivos (como no caso de propriedades do tipo &lt;code class=&quot;highlighter-rouge&quot;&gt;Boolean&lt;/code&gt;, e.g. &lt;code class=&quot;highlighter-rouge&quot;&gt;Finalizado&lt;/code&gt; ou &lt;code class=&quot;highlighter-rouge&quot;&gt;EstaFinalizado&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;Ainda com relação a propriedades booleanas, você pode usar os prefixos &lt;code class=&quot;highlighter-rouge&quot;&gt;Is&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Can&lt;/code&gt; ou &lt;code class=&quot;highlighter-rouge&quot;&gt;Get&lt;/code&gt;, caso isso facilite o entendimento da propriedade.&lt;/p&gt;

&lt;p&gt;Abrindo um parênteses. Aqui entramos mais uma vez &lt;a href=&quot;(http://carlosschults.net/pt/programar-portugues-ou-ingles/)&quot;&gt;naquela velha discussão sobre português x inglês&lt;/a&gt;. Muita gente vai dizer que misturar português e inglês como em &lt;code class=&quot;highlighter-rouge&quot;&gt;IsValido&lt;/code&gt; é algo horrível e que jamais deveria ser feito. Outros vão argumentar que o uso de &lt;code class=&quot;highlighter-rouge&quot;&gt;Is&lt;/code&gt; é um idioma facilmente reconhecível por qualquer programador e que tentar aportuguesá-lo como em &lt;code class=&quot;highlighter-rouge&quot;&gt;EValido&lt;/code&gt; ou &lt;code class=&quot;highlighter-rouge&quot;&gt;EhValido&lt;/code&gt; é bem pior. É uma discussão que dá pano pra manga. &lt;a href=&quot;http://carlosschults.net/pt/programar-portugues-ou-ingles/&quot;&gt;Clique aqui para saber minha opinião a respeito.&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;use-nomes-pronunciveis-e-passveis-de-busca&quot;&gt;9. Use nomes pronunciáveis e passíveis de busca&lt;/h2&gt;

&lt;p&gt;Se esforce para escolher nomes que são pronunciáveis. Quando você escolhe um nome que é difícil ou impossível de ser pronunciado, você desencoraja a discussão sobre o código, o que nunca é uma boa coisa.&lt;/p&gt;

&lt;p&gt;Do mesmo jeito, evite nomes com uma letra só. Entre outras razões, você vai sofrer bastante quando tiver que fazer uma busca por eles! Nomes de uma letra só são bons apenas para variáveis de controle em laços de repetição e em expressões lambda. E ainda assim, só quando o escopo é bem curto.&lt;/p&gt;

&lt;h2 id=&quot;concluso&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Escolher nomes não é uma tarefa fácil. Um nome precisa expressar propósito, intenção, significado. Ele não precisa ser necessariamente “esperto”, mas tem situações na qual um pouco de esperteza vai ser necessário.&lt;/p&gt;

&lt;p&gt;Um nome deveria expressar claramente o propósito da entidade nomeada. Mas existem coisas que são muito complexas por sua própria natureza, o que torna difícil encontrar um nome que expressa seu propósito de forma simples e clara.&lt;/p&gt;

&lt;p&gt;Às vezes, a dificuldade que você tem ao escolher um nome é sintomas de outro problema, tal como uma arquitetura ruim. Se você não consegue se decidir entre cinco possíveis nomes para uma classe, talvez ela esteja violando o Princípio da Responsabilidade Única (ela está tentando fazer mais de uma coisa).&lt;/p&gt;

&lt;p&gt;Por outro lado, se você se sente inclinado a nomear uma dúzia de classes com o mesmo nome…talvez elas deveriam ser uma classe só.&lt;/p&gt;

&lt;p&gt;No fim das contas, escolha de nomes tem a ver com comunicação. E eu acho que é por isso que é uma tarefa tão difícil. Convenhamos: nós, desenvolvedores de software, não somos famosos por nossas habilidades de comunicação.&lt;/p&gt;

&lt;p&gt;Em “Código Limpo”, no final do capítulo sobre escolher bons nomes, Uncle Bob fala:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;O mais difícil sobre escolher bons nomes é a necessidade de se possuir boas habilidades de descrição e um histórico cultural compartilhado. Essa é uma questão de aprender, e não técnica, gerencial ou empresarial. Como consequência, muitas pessoas nessa área não aprendem essa tarefa muito bem.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Não seja igual a maioria das pessoas na nossa área. Trabalhe dure para aprender a criar bons nomes. Você vai se agradecer no futuro.&lt;/p&gt;
</description>
        <pubDate>Sun, 22 May 2016 00:00:00 -0300</pubDate>
        <link>http://carlosschults.net/pt/como-escolher-bons-nomes/</link>
        <guid isPermaLink="true">http://carlosschults.net/pt/como-escolher-bons-nomes/</guid>
        
        <category>boas práticas</category>
        
        
      </item>
    
      <item>
        <title>Fases de Estabilização</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://res.cloudinary.com/dz5ppacuo/image/upload/v1462111255/balance-min_qkdhxx.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NOTA&lt;/strong&gt;: O artigo a seguir foi originalmente escrito por Robert C. Martin, mais conhecido como Uncle Bob. Bob é um programador com décadas de experiência, autor de diversos livros (Código Limpo, por exemplo) e foi o organizador do encontro em 2001 que deu origem ao &lt;a href=&quot;http://agilemanifesto.org/iso/ptbr/&quot;&gt;Manifesto Para Desenvolvimento Ágil de Software&lt;/a&gt;. Ele gentilmente me autorizou a fazer essa tradução. Caso lhe interesse, &lt;a href=&quot;http://blog.cleancoder.com/uncle-bob/2016/01/14/Stabilization.html&quot;&gt;clique aqui para ler o artigo original&lt;/a&gt;.
&lt;!--more--&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;Enquanto tomava meu café de manhã e dava uma olhada no facebook em meu celular, fui inundado com updates de status de proprietários de veículos Tesla que estavam animados porque seus carros agora poderiam entrar na garagem de maneira autônoma. Minha resposta a esses posts no facebook talvez tenha sido um pouco cínica; mas eu disse a todos eles:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Vai demorar muito até eu confiar em um software para dirigir o carro no qual eu estou.
Porque eu – &lt;strong&gt;sei&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Eu sei o quê? Eu sei o quão difícil é testar software para cada imprevisto. 
E eu sei como é fácil enganar a si próprio achando que você testou.&lt;/p&gt;

&lt;p&gt;E isso me fez pensar sobre como você deveria testar o software de um carro autônomo.&lt;/p&gt;

&lt;p&gt;E isso me fez pensar sobre como as pessoas de fato testam sistemas de software.&lt;/p&gt;

&lt;p&gt;E isso finalmente me fez pensar sobre fases de estabilização.&lt;/p&gt;

&lt;p&gt;Você sabe o que é uma fase de estabilização, não sabe? Uma fase de estabilização ocorre no final de uma release. Algum tempo é reservado para apenas deixar o sistema rodar. Por uma semana, ou um mês, todo mundo apenas assiste o sistema rodando. Eles o tratam como um bebê dormindo. Eles evitam barulhos altos, batidas de portas, e conversa alta. Eles andam nas pontas dos dedos, dando uma olhadinha de tempos em tempos, com a esperança de que ele não acorde e quebre.&lt;/p&gt;

&lt;p&gt;OK, talvez isso seja um pouco exagarado. – Talvez. Eu imagino que a maioria dos times que usam fases de estabilização realmente trabalham muito duro para estressar seus sistemas. Pelo menos eu espero que eles façam isso. Eles deveriam estar inserindo muitos dados no dados sob condições diversas; incluindo dados incorretos, e que causaram problemas no passado.&lt;/p&gt;

&lt;p&gt;Mas essa é a coisa importante sobre fases de estabilização:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Nós as usamos porque temos medo. 
Nós temos medo porque não temos certeza do que o sistema irá fazer.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Há uma certa dissonância cognitiva entre dizer que somos profissionais, e sermos tão incertos sobre o que criamos que temos medo do que pode fazer. Geralmente se espera que uma equipe de profissionais tenha um alto grau de confiança e certeza.&lt;/p&gt;

&lt;p&gt;Quanto maior o tempo de duração da fase de estabilização, menor é a certeza que o time tem sobre o sistema. As equipes que precisam de apenas um dia têm muito mais confiança em seus sistemas que as equipes que querem uma semana, ou um mês.&lt;/p&gt;

&lt;p&gt;A falha lógica aqui é que tempo de execução indica qualidade. Mas tempo na verdade não é relacionado à qualidade. Tempo simplesmente cria falsa confiança.&lt;/p&gt;

&lt;p&gt;O comportamento do sistema na fase de estabilização tem pouco ou nada a ver com o comportamento do sistema em produção; porque os dados entrando no sistema de produção são dados completamente novos. Os novos dados podem levar o sistema a percorrer caminhos que a fase de estabilização nunca executou.&lt;/p&gt;

&lt;p&gt;Então fases de estabilização apenas criam falsa confiança. Elas são uma estratégia para “tirar o seu da reta.” Quando o sistema falha em produção, você pode pelo menos dizer que você fez o esforço devido de rodar o sistema por um mês na fase de estabilização; dessa forma exonerando a equipe da culpa de deixar um defeito crítico entrar no sistema.&lt;/p&gt;

&lt;p&gt;O problema crucial é que a fase de estabilização existe porque o time de desenvolvimento produziu código no qual eles não confiam. Então eles rodam o sistema por um mês para criar suficiente falsa confiança para enfrentar a incerteza.&lt;/p&gt;

&lt;p&gt;O que a equipe realmente precisa fazer é atacar sua incerteza diretamente. Não rodando o sistema inutilmente por um mês; mas sim corrigindo os problemas no seu processo de desenvolvimento que criaram essa incerteza. Considere o checklist seguinte:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Você está executando ferramentas de cobertura? Você checa se cada if e while estão cobertos?&lt;/li&gt;
  &lt;li&gt;A cobertura de testes unitários é próxima de 100%?&lt;/li&gt;
  &lt;li&gt;Você precisa aumentar um pouco a cobertura escrevendo mais testes?&lt;/li&gt;
  &lt;li&gt;Você tem testes de aceitação automatizados escritos por (ou pelo menos validados por) pessoas de negócio e Garantia de Qualidade?&lt;/li&gt;
  &lt;li&gt;A cobertura de testes é alta o suficiente? Você precisa aumenta-la um pouco pedindo para a GQ considerar mais alguns casos extremos?&lt;/li&gt;
  &lt;li&gt;Você tem testes de integração automatizados escritos por arquitetos e desenvolvedores líderes?&lt;/li&gt;
  &lt;li&gt;Esses testes estressam os caminhos de comunicação entre os componentes?&lt;/li&gt;
  &lt;li&gt;Eles checam por casos excepctionais, problemas nos limites e timeouts?&lt;/li&gt;
  &lt;li&gt;Eles examinam o comportamento do sistema sob cargas variáveis?&lt;/li&gt;
  &lt;li&gt;Se você tem múltiplas threads, você tem uma estratégia para estressar essas threads durante seus testes unitários e testes de aceitação?&lt;/li&gt;
  &lt;li&gt;Por exemplo, você implementou ferramentas que introduzem delays aleatórios e cargas aleatórios para que as probabilidades de condições de corrida sejam aumentadas?&lt;/li&gt;
  &lt;li&gt;Melhor ainda, você está gradualmente eliminando a possbilidade de condições de corrida por meio da eliminação de estados mutáveis entre threads? Você desenhou todos os diagramas de sequência de mensagens e os examinou em busca de corridas em potencial?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Esse checklist é só um exemplo. Eu tenho certeza que você consegue pensar em mais coisas para acrescentar. O ponto é que é melhor ser proativo a respeito da sua incerteza, do que ser passivo a respeito dela. E fases de estabilização são passivas.&lt;/p&gt;

&lt;p&gt;O objetivo de equipes de software que estão atualmente usando fases de estabilização deveria ser aumentar sua confiança com o tempo, e dessa forma reduzir a duração de suas fases de estabilização. Reduza de um mês, para uma semana. Então de uma semana para um dia. Então de um dia para uma hora.&lt;/p&gt;

&lt;p&gt;E então, finalmente, aumenta sua confiança ao ponto de poder eliminar a fase de estabilização de uma vez por todas.&lt;/p&gt;

&lt;p&gt;Uma historinha:&lt;/p&gt;

&lt;p&gt;Eu recentemente fiz um test-drive com uma Tesla. É um carro divertido de se dirigir. Realmente divertido. 
Eu testei a funcionalidade de piloto automático, que é facilmente ativada apertando um botão na coluna de direção. 
O carro alegremente lhe informa que a partir de agora está dirigindo a si mesmo; e lhe alerta para manter as mãos no volante. Preste atenção nesse aviso!&lt;/p&gt;

&lt;p&gt;O carro se saiu razoavelmente bem quando as marcas na estrada eram visíveis, mas parecia bastante disposto a me arrebentar em algumas barragens de construção. Não é seguro tirar suas mãos do volante ou seus olhos da pista. Para mim, isso torna a funcionalidade menos que inútil.&lt;/p&gt;

&lt;p&gt;O vendedor estava sentado do meu lado. Em um certo momento nós estávamos indo a 70 km/h em direção à traseira de um carro parado no sinal fechado. O vendedor disse: “Confie no carro.” E eu pensei: “Até parece!” E &lt;strong&gt;eu&lt;/strong&gt; freei o carro. 
A tecnologia é interessante; mas perigosa. NUNCA “confie no carro”!&lt;/p&gt;

&lt;p&gt;Talvez você tenha percebido que a perspectiva de carros autônomos não me enche de entusiasmo. Eu vou continuar pensando o que será que esses carros farão um segundo após 29 de fevereiro.&lt;/p&gt;
</description>
        <pubDate>Mon, 02 May 2016 00:00:00 -0300</pubDate>
        <link>http://carlosschults.net/pt/traducao-fases-estabilizacao/</link>
        <guid isPermaLink="true">http://carlosschults.net/pt/traducao-fases-estabilizacao/</guid>
        
        <category>traduções</category>
        
        <category>metodologias ágeis</category>
        
        <category>integração contínua</category>
        
        <category>testes de software</category>
        
        <category>testes automatizados</category>
        
        
      </item>
    
      <item>
        <title>Testes unitários para iniciantes - Parte 1</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://res.cloudinary.com/dz5ppacuo/image/upload/v1459979937/testes-unitarios-iniciantes-min_povcse.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Você já deve ter trabalhado em um sistema assim: incrivelmente complexo, com uma base de código gigantesca, mal documentada, cheia de gambiarras, acoplamentos desnecessários, com arquitetura confusa, especificações inexistentes, onde era quase considerado um milagre que o software chegasse a funcionar. Talvez eu tenha acabado de descrever seu projeto atual!
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;Nesse tipo de projeto, é comum que os desenvolvedores fiquem com receio de mexer no código, pois sabem que, inevitavelmente, algo vai quebrar. E provavelmente, o erro só vai ser descoberto em produção.&lt;/p&gt;

&lt;p&gt;Agora, imagine se a aplicação fosse completamente protegida por um sistema de alarmes. Cada vez que uma &lt;em&gt;feature&lt;/em&gt; parasse de funcionar, o alarme dispararia. Os desenvolvedores seriam imediatamente notificados, e alguém resolveria o problema o mais rápido possível.&lt;/p&gt;

&lt;p&gt;Imagine ainda que esse sistema de alarmes fosse composto por centenas de sistemas menores. Cada um desses subsistemas seria responsável por “vigiar” uma parte bem pequena e específica da sua aplicação. E para que o sistema de alarmes funcionasse bem, os subsistemas deveriam ser totalmente independentes uns dos outros.&lt;/p&gt;

&lt;p&gt;A adoção de um sistema desse tipo traria muitos benefícios. Logo de cara, o medo de mexer no código iria embora. A refatoração se tornaria mais fácil e frequente, e, como consequência, a qualidade do código aumentaria.&lt;/p&gt;

&lt;p&gt;O próprio processo de desenvolvimento seria simplificado. O sistema de alarmes reduziria drasticamente a necessidade dos lentos testes manuais, agilizando a entrega da aplicação para os usuários.&lt;/p&gt;

&lt;p&gt;Por fim, a necessidade de independência entre os subsistemas incentivaria a diminuição do acoplamento entre as partes da aplicação.&lt;/p&gt;

&lt;p&gt;Parece bom demais para ser verdade? Pois saiba que não é. Esse sistema de alarmes é o benefício que você ganha ao implementar uma &lt;strong&gt;suíte de testes unitários&lt;/strong&gt; em sua aplicação.&lt;/p&gt;

&lt;h2 id=&quot;o-que-so-testes-unitrios&quot;&gt;O que são testes unitários&lt;/h2&gt;

&lt;p&gt;Vamos ver a definição da Wikipédia:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;In computer programming, unit testing is a software testing method by which individual units of source code, […] are tested to determine whether they are fit for use. Intuitively, one can view a unit as the smallest testable part of an application.  […]
 Unit tests are typically written and run by software developers to ensure that code meets its design and behaves as intended.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Em tradução livre:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Em programação de computadores, teste unitário é um método de teste de software pelo qual unidades individuais de código fonte […] são testadas para determinar se são adequadas para o uso. Intuitivamente, pode-se considerar uma unidade como a menor parte testável de uma aplicação. […]
 Testes unitários são tipicamente escritos e executados por desenvolvedores para garantir que o código está de acordo com o projeto e se comporta da maneira desejada.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A primeira coisa que chama a atenção é que os testes unitários &lt;strong&gt;não têm o propósito de testar o sistema como um todo&lt;/strong&gt;. Pelo contrário, eles testam pequenas partes do software - as tais das unidades. E o que é uma unidade? Existem diversos pontos de vista conflitantes sobre isso, diversas “escolas de pensamento”. Mas é seguro dizer que, no contexto de programação orientada a objeto, a maioria das pessoas considera unidade como sendo uma &lt;strong&gt;classe&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Logo a seguir, nós vemos que os testes unitários são tipicamente escritos e executados por programadores. Isso é interessante por dois motivos: primeiro, contradiz uma ideia antiga de que programadores não são bons testadores de software (vou voltar nesse ponto depois). E mais importante do que isso, ele deixa claro a principal característica dos testes unitários: eles são &lt;strong&gt;automatizados&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Tenha em mente que existem diversos tipos de testes automatizados, mas aqui estamos tratando apenas de testes unitários (os quais, de acordo com diversos autores, tais como &lt;a href=&quot;http://martinfowler.com/bliki/TestPyramid.html&quot;&gt;Martin Fowler&lt;/a&gt;, são os que trazem mais benefícios para uma aplicação).&lt;/p&gt;

&lt;p&gt;Na prática, os testes unitários consistem de classes contendo métodos que testam partes pequenas e isoladas do sistema. Essas classes são criadas com o auxílio de um framework de testes (como o JUnit no Java, ou o NUnit ou o Microsoft Test no .Net). Esses testes podem então ser executados pela linha de comando, pela sua IDE ou mesmo por um serviço de build automatizado.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://res.cloudinary.com/dz5ppacuo/image/upload/v1460211309/teste00_bnsbfl.png&quot; alt=&quot;Exemplo de método de teste em C#&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Após a execução dos testes, você obtém um retorno imediato sobre quais testes passaram e quais falharam, acompanhado do tempo de execução de cada um dos testes.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://res.cloudinary.com/dz5ppacuo/image/upload/v1459979476/teste01_ciglca.png&quot; alt=&quot;Janela exibindo resultados da execução de testes unitários&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Com base nesse feedback, você decide o melhor curso de ação. Idealmente, um teste que falha deveria ser sinal de erro no código. O código de produção deveria então ser ajustado para que o teste volte a passar.&lt;/p&gt;

&lt;h2 id=&quot;benefcios-dos-testes-unitrios&quot;&gt;Benefícios dos testes unitários&lt;/h2&gt;

&lt;p&gt;No começo do post, ao usar a metáfora do sistema de alarmes, eu falei de alguns dos benefícios que os testes unitários trazem, como por exemplo:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;incentivo à refatoração;&lt;/li&gt;
  &lt;li&gt;incentivo à evolução da arquitetura do sistema;&lt;/li&gt;
  &lt;li&gt;simplificação e agilidade na entrega do produto aos usuários;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Outro benefício que vale a pena citar é que os testes também servem como &lt;strong&gt;documentação do código&lt;/strong&gt;. Pense bem: para cada classe de produção no seu sistema, existem diversos métodos de teste que exercitam e exemplificam todos os usos possíveis dessa classe. Uma boa suíte de testes poderia ajudar um recém-chegado ao time adquirir familiaridade com a base de código em pouco tempo.&lt;/p&gt;

&lt;p&gt;Ou seja: documentação viva, executável, sempre atualizada, e que nunca mente.&lt;/p&gt;

&lt;p&gt;Não podemos deixar de mencionar também que uma boa suíte de testes unitários também ajuda a prevenir a regressão de bugs. É uma ótima prática criar um novo teste toda vez que um bug for encontrado. Assim, caso alguma alteração futura faça com que o bug retorne (“regresse”), o teste vai indicar isso.&lt;/p&gt;

&lt;p&gt;Finalmente, um dos maiores benefícios da automação de testes que eu não vejo sendo alardeado por aí é a redução de custos - talvez por ser um fator mais de negócios do que técnico. Digamos que antes de cada release a sua equipe faça um teste completo na aplicação, com quatro testadores, trabalhando 8 horas por dia, durante duas semanas. Basta fazer uma simples multiplicação e você verá que &lt;strong&gt;testes manuais custam caro.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Pior ainda: eles custam caro duas vezes. Primeiro, há o custo dos testes em si, que você pode calcular com a fórmula &lt;em&gt;valor da hora de trabalho dos testadores x nº de testadores x horas gastas em teste.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Além disso, há o &lt;a href=&quot;https://pt.wikipedia.org/wiki/Custo_de_oportunidade&quot;&gt;custo de oportunidade&lt;/a&gt;: quando profissionais precisam desempenhar testes manuais que poderiam ser automatizados, eles estão deixando de desempenhar atividades criativas/intelectuais que teriam potencial de trazer ganhos muito maiores para a empresa.&lt;/p&gt;

&lt;h2 id=&quot;equvocos-comuns&quot;&gt;Equívocos comuns&lt;/h2&gt;

&lt;p&gt;Nessa seção, vou tentar esclarecer alguns dos mitos e equívocos que existem a respeito de testes unitários.&lt;/p&gt;

&lt;h3 id=&quot;programadores-no-deveriam-escrever-testes-pois-geralmente-so-maus-testadores&quot;&gt;Programadores não deveriam escrever testes, pois geralmente são maus testadores&lt;/h3&gt;

&lt;p&gt;Existe uma ideia bastante difundida de que programadores não deveriam testar seu próprio código. O raciocínio é que eles, inconscientemente, evitariam usar a aplicação de uma maneira que a faria quebrar. E por experiência própria, eu digo que isso de fato acontece. Já perdi a conta de quantas vezes algum colega encontrou bugs em uma aplicação que eu fiz após &lt;strong&gt;segundos&lt;/strong&gt; de uso, sendo que eu já havia passado muito mais tempo que isso testando e sem conseguir fazer falhar.&lt;/p&gt;

&lt;p&gt;O ponto a salientar aqui é: &lt;strong&gt;há testes e testes&lt;/strong&gt;. Geralmente, quando pessoas dizem que programadores não deveriam testar, elas estão se referindo a testes de sistema, também chamados testes ponta a ponta. Tais testes têm o propósito de testar o sistema como um todo, o que, como já vimos, não é o objetivo dos testes unitários.&lt;/p&gt;

&lt;p&gt;Muitas vezes o que ocorre é simplesmente falta de informação: a pessoa talvez desconheça a natureza e propósito dos testes unitários, e os toma por testes de ponta a ponta.&lt;/p&gt;

&lt;h3 id=&quot;escrever-testes-unitrios--uma-perda-de-tempo--o-mesmo-que-programar-duas-vezes&quot;&gt;Escrever testes unitários é uma perda de tempo; é o mesmo que programar duas vezes&lt;/h3&gt;

&lt;p&gt;Ao tentar “vender” testes unitários para a gerência na sua empresa, uma boa estratégia é apelar para a redução de custos, como visto anteriormente. Mas…e os desenvolvedores? Como convencê-los a gastar mais tempo escrevendo código de teste além do código de produção?&lt;/p&gt;

&lt;p&gt;Dizer que os testes unitários são perda de tempo é uma justificativa comum apresentada por desenvolvedores que não querem escrever testes. E é uma justificativa aparentemente legítima. Afinal, nossos prazos são apertadíssimos, como podemos arrumar tempo para ficar escrevendo casos de teste?&lt;/p&gt;

&lt;p&gt;O que essas pessoas falham em perceber é que &lt;em&gt;elas já testam o próprio código constantemente, mesmo que não chamem por esse nome.&lt;/em&gt; É bem provável que seu workflow de desenvolvimento seja bem parecido com isso:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Escreve um pouco de código&lt;/li&gt;
  &lt;li&gt;Compila&lt;/li&gt;
  &lt;li&gt;Executa a aplicação, testa a funcionalidade
    &lt;ul&gt;
      &lt;li&gt;Se funcionou, começa a escrever a próxima funcionalidade&lt;/li&gt;
      &lt;li&gt;Se não funcionou, passa um tempo debugando até encontrar e corrigir o erro&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Repita&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;O que estamos propondo é simplesmente trocar o ciclo “escreve código de produção -&amp;gt; compila -&amp;gt; testa -&amp;gt; debuga -&amp;gt; repete” pelo ciclo “escreve código de produção -&amp;gt; escreve código de testes -&amp;gt; executa testes -&amp;gt; corrige código de produção se necessário”.&lt;/p&gt;

&lt;p&gt;É até possível argumentar que os ciclos são praticamente os mesmos. Mas a grande vantagem dos testes unitários é que, uma vez escritos, eles estão automatizados para o resto da vida do projeto. Você “perde tempo” só uma vez. Você investe tempo e esforço no começo, para criar os testes, e colhe os benefícios por tempo indefinido.&lt;/p&gt;

&lt;h3 id=&quot;testes-unitrios-substituem-todos-os-testes-manuais&quot;&gt;Testes unitários substituem todos os testes manuais&lt;/h3&gt;

&lt;p&gt;Testes unitários não são os únicos tipos de testes que trazem benefícios a um projeto. Também podemos utilizar outros tipos de testes automatizados como &lt;strong&gt;testes de integração&lt;/strong&gt; e &lt;strong&gt;testes de aceitação&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://res.cloudinary.com/dz5ppacuo/image/upload/v1460217453/testing_triangle-300x233_nzq8kx.jpg&quot; alt=&quot;Triângulo dos testes, mostrando a razão ideal entre os diversos tipos de teste de software&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Isso não significa que testes manuais devem ser extintos. Pelo contrário, eles continuam tendo um papel importante no processo de controle de qualidade. De preferência, os testes manuais devem se concentrar nas áreas que não podem ser automatizadas, como testes de usabilidade.&lt;/p&gt;

&lt;p&gt;Dentro de um contexto de metodologias ágeis, é essencial que o Product Owner/Cliente/Pessoa de Negócios valide e aceite as histórias antes delas serem incluídas em uma release.&lt;/p&gt;

&lt;p&gt;Testes manuais exploratórios, que não seguem um roteiro definido, costumam ser valiosos na detecção de certos tipos de bugs. Os casos de testes automatizados tendem a focar no “Happy Path”, ou seja, o cenário no qual deu tudo certo, as unidades foram usadas exatamente do jeito que o codificador pensou e projetou. Na vida real, é muito comum que os usuários utilizem a aplicação de maneiras…como dizer?…“criativas”. Então,colocar o software sob stress, utilizando-o de maneiras diferentes e inesperadas, podem acabar revelando bugs que de outra forma permaneceriam ocultos.&lt;/p&gt;

&lt;p&gt;É claro que, uma vez que o bug tenha sido revelado pelo teste manual, deve-se imediatamente escrever um teste automatizado que o exponha. Assim, na eventualidade do bug regredir, ele será facilmente detectado.&lt;/p&gt;

&lt;h2 id=&quot;concluso&quot;&gt;Conclusão&lt;/h2&gt;

&lt;p&gt;Testes unitários - e automação de testes, no geral - são um tema gigantesco. Há muitos livros sobre esse tema, bem como teses de mestrado. Há conferências anuais em diversos países apenas sobre teste de software. Então, é claro que seria impossível que eu, com uma mera postagem no meu blog, fizesse jus a esse tema.&lt;/p&gt;

&lt;p&gt;Mas eu espero, sinceramente, ter feito uma boa introdução aos testes unitários e esclarecido um pouco das dúvidas que os iniciantes geralmente têm. Qualquer dúvida, sugestão ou crítica, a área de comentário é de vocês.&lt;/p&gt;

&lt;p&gt;Este post é o início de uma série dedicada ao tema dos testes.
No próximo artigo, começaremos a colocar a mão na massa: vou mostrar a vocês como criar seus primeiros testes!&lt;/p&gt;

&lt;p&gt;Até lá!&lt;/p&gt;
</description>
        <pubDate>Sat, 09 Apr 2016 00:00:00 -0300</pubDate>
        <link>http://carlosschults.net/pt/testes-unitarios-iniciantes-parte1</link>
        <guid isPermaLink="true">http://carlosschults.net/pt/testes-unitarios-iniciantes-parte1</guid>
        
        <category>testes de software</category>
        
        <category>testes unitários</category>
        
        <category>metodologias ágeis</category>
        
        <category>testes automatizados</category>
        
        
      </item>
    
      <item>
        <title>Programar em português ou inglês? That&#39;s the question!</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://res.cloudinary.com/dz5ppacuo/image/upload/v1458429920/portugues-ou-ingles-1038x437_izhi3i.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;No contexto de boas práticas de desenvolvimento, um ponto que gera controvérsia é a escolha do idioma no qual codificar. Uma rápida busca no Google por “programar em português ou inglês” retorna 535 mil resultados, o que mostra que o tema realmente causa bastante discussão. 
&lt;!--more--&gt;
Recentemente conversei com um colega de trabalho e também com meu chefe a respeito desse assunto. Esse post é consequência dessas conversas e das pesquisas que fiz depois.&lt;/p&gt;

&lt;p&gt;Parece ser uma visão bastante comum na nossa área que programar em inglês é a melhor opção. Fabio Akita, grande referência na comunidade Ruby On Rails do Brasil, &lt;a href=&quot;http://www.akitaonrails.com/2013/03/24/quais-sao-algumas-das-piores-praticas-para-aplicacoes-ruby-on-rails--2&quot;&gt;inclui codificar em português - ou melhor dizendo, qualquer idioma que não o inglês - na sua lista de piores práticas de desenvolvimento&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Escreva nomes em inglês dentro do seu código. Não me importo se você é brasileiro, italiano, francês ou o que   for. Nomes de classes, de variáveis, de métodos, tudo deve ser em inglês. Estamos num mundo globalizado, não é pensar muito longe que amanhã um americano vai mexer no seu código todo em português. Além do problema de consistência: a sintaxe da linguagem, todas as bibliotecas padrão, é tudo em inglês. É uma enorme dissonância cognitiva ter nomes em português no meio. É como você estar lendo uma revista em português com diversos parágrafos em inglês no meio. Não faz nenhum sentido.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Carlos Brando, outro nome conhecido no mundo Rails, &lt;a href=&quot;http://nomedojogo.com/2009/02/13/rails-way-3-nomes-de-metodos-e-variaveis-devem-ser-obvios/&quot;&gt;deu opinião semelhante em um post de 2009&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Embora não exista uma regra escrita para isto, também sou contra nomear variáveis, métodos ou classe em português. Acho que como todo o código já está em inglês, graças as palavras chaves do Ruby, devemos manter absolutamente tudo em inglês também. Isto não é tão difícil assim, já que você pode fazer uso de tradutores e dicionários (online) para encontrar a melhor descrição para eles.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Um exemplo de como esse tema é inflamável: &lt;a href=&quot;http://blog.stackoverflow.com/2014/01/ola-mundo-announcing-stack-overflow-in-portuguese/&quot;&gt;há cerca de dois anos foi lançada a versão em português do Stack Overflow&lt;/a&gt;, famoso site de perguntas e respostas pra programadores. Pare aqui e vá lá dar uma olhada no post. Viu a quantidade de comentários criticando a iniciativa? A controvérsia foi tanta que duas semanas depois a equipe do Stack Overflow publicou um novo post, dessa vez em inglês, justificando a decisão.&lt;/p&gt;

&lt;p&gt;Eu acredito que a discussão é necessária e saudável e que existem bons argumentos nos dois lados. Assim, vou  examinar opiniões a favor do uso de cada idioma, e ao final do post, expressar minha conclusão.&lt;/p&gt;

&lt;h2 id=&quot;argumentos-a-favor-do-ingls&quot;&gt;Argumentos a favor do inglês&lt;/h2&gt;

&lt;p&gt;Um dos argumentos mais comuns usados a favor do inglês é que seria estranho ou feio misturar dois idiomas na codificação. Como as palavras reservadas das linguagens de programação/frameworks/SGBD’s já são em inglês, utilizar a língua portuguesa para nomear variáveis e outras coisas acaba gerando híbridos como &lt;em&gt;getNome&lt;/em&gt;, &lt;em&gt;ProdutosController&lt;/em&gt;, &lt;em&gt;clientes.ForEach&lt;/em&gt;, &lt;em&gt;CodigoNaoEncontradoException&lt;/em&gt; e assim por diante. No trecho citado logo ali acima, Fabio Akita afirma que a mistura dos idiomas causa uma dissonância cognitiva, seria como ler uma página escrita em um idioma e de repente se deparar com parágrafos escrito em outro.&lt;/p&gt;

&lt;p&gt;Outro argumento comum, também utilizado pelo Akita no trecho citado, é a possibilidade de um programador não-brasileiro vir a trabalhar no projeto. Imagine um projeto que conte com desenvolvedores da França, Alemanha, Brasil, Estados Unidos. Se cada um resolve programar no seu idioma, a comunicação se tornará impossível, a menos que todos os membros da equipe sejam proficientes nos idiomas de todos os outros membros, o que seria bastante improvável.&lt;/p&gt;

&lt;p&gt;Um ponto bem parecido com o anterior é que a utilização do português prejudicaria uma eventual venda do produto para uma empresa de outro país, o que é de fato inegável.&lt;/p&gt;

&lt;p&gt;O fato de que o inglês é a língua franca da tecnologia também figura constantemente entre os argumentos dos defensores do uso dessa língua na codificação. Segundo eles, qualquer desenvolvedor que se preze &lt;strong&gt;precisa&lt;/strong&gt; ter um domínio avançado da língua inglesa. Sendo assim, o uso da inglês na verdade facilitaria o desenvolvimento, e não o contrário.&lt;/p&gt;

&lt;p&gt;Outro ponto interessante a favor do inglês é que os identificadores nesse idioma tendem a ser menores, o que incentiva a um código mais limpo e conciso. Por exemplo, compare &lt;em&gt;setName&lt;/em&gt; com &lt;em&gt;atribuirNome&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Uma consequência do ponto anterior é que o uso de um único idioma ajuda a consolidar um vocabulário compartilhado entre todos os programadores. &lt;em&gt;Get&lt;/em&gt; e &lt;em&gt;Set&lt;/em&gt;, por exemplo, são palavras-chaves familiares para a maioria dos desenvolvedores, por serem extremamente comuns em API’s e bibliotecas diversas. Digamos que um programador recém-chegado à sua empresa recebe a tarefa de dar manutenção em uma biblioteca que vocês desenvolveram para trabalhar com XML. Ele provavelmente teria mais facilidade em encontrar um método chamado &lt;em&gt;GetChildren()&lt;/em&gt; do que se fosse chamado ObterFilhos().&lt;/p&gt;

&lt;p&gt;Outra vantagem da utilização do inglês seria…que ela melhora o seu conhecimento de inglês. Já que programadores precisam dominar esse idioma de qualquer forma, toda e qualquer oportunidade de praticá-lo é válida.&lt;/p&gt;

&lt;h2 id=&quot;argumentos-a-favor-do-portugus&quot;&gt;Argumentos a favor do português&lt;/h2&gt;

&lt;p&gt;Um argumento a favor do uso do português é a baixa proficiência em inglês apresentada pelos desenvolvedores brasileiros em geral, e como isso pode prejudicar a comunicação não apenas entre os desenvolvedores, mais também entre os desenvolvedores e as pessoas de negócio:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Da mesma forma, uma regra de negócio traduzida para o inglês pode ser mal traduzida por quem não domina o idioma. Falsos cognatos existem e podem ser utilizados nessa tradução cotidiana. Imagine que, ao invés de criar classes chamadas Funcionario e Empregador você crie classes chamadas Employee e Employer. Isso seria tão confuso para um desenvolvedor que não domina o inglês, quanto para um desenvolvedor que domina o inglês. Na hora de programar, os termos podem misturar-se.
&lt;a href=&quot;http://www.ventron.com.br/programar-em-portugues-ou-ingles/&quot;&gt;Gustavo Gondim&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Eu já vi tantas atrocidades na transliteração de português para inglês usando Google Translator… Na falta da compreensão, pega-se a primeira palavra que aparece. Ou cria-se expressões com termos em inglês usando a sintaxe do português. Confunde-se a forma de usar substantivos, verbos e adjetivos. A língua resultante pode ser inglês de índio, mas não é inglês. O ponto é que em uma equipe que não fala inglês nativamente, usar os termos de negócio em inglês pode complicar até o entendimento entre os programadores.[…]
&lt;a href=&quot;https://blogdofernandocorreia.wordpress.com/2011/09/21/que-lingua-usar-para-nomes-do-dominio-de-negocio/&quot;&gt;Fernando Correia&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Resumindo: uma equipe que tem domínio superficial do inglês necessariamente produz inglês de baixa qualidade, por não estar ciente das “pegadinhas” que o idioma pode apresentar (por exemplo: falsos cognatos). Mas ainda tem mais: é de conhecimento geral que programadores passam mais tempo lendo código do que escrevendo. E qualquer programador com alguma experiência vai concordar que ler código é bem mais difícil do que escrever. Ao forçar uma equipe sem desenvoltura na língua inglesa a trabalhar com uma base de código escrita nessa língua, estaríamos aumentando a barreira necessária para a compreensão do código, dificultando a manutenção e aumentando a chance de criação de bugs.&lt;/p&gt;

&lt;p&gt;O &lt;a href=&quot;http://programandosemcafeina.blogspot.com.br/2009/03/nomes-de-metodos-e-variaveis-devem-ser.html&quot;&gt;Tiago Albineli Motta, do blog “Programando Sem Cafeína”&lt;/a&gt;, traz um argumento bem interessante: de que o uso de idiomas diferentes prejudica a comunicação entre cliente e a equipe de desenvolvimento, principalmente quando o domínio do negócio é bastante específico. Para justificar, ele cita o exemplo de quando trabalhava em uma empresa que estava desenvolvimento um sistema para um laboratório geológico. Como os funcionários do laboratório usavam termos em português e a equipe de desenvolvimento em inglês, havia ruídos na comunicação.&lt;/p&gt;

&lt;p&gt;Destaco um trecho interessante abaixo (destaque meu):&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Eis então a pergunta: Será que um código que mistura termos em inglês e português causa mais problemas que os ruídos na comunicação com o cliente? Pode-se alegar que o código nem será mostrado ao usuário, &lt;strong&gt;mas na hora em que o desenvolvedor precisa se comunicar com o cliente, na mente dele ele não está trabalhando com amostras, ele está trabalhando com samples.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ainda no tema do domínio, poderíamos imaginar o desenvolvimento de uma aplicação que se integra com a famigerada Nota Fiscal Eletrônica. Como o xml da nota já vem com os campos todos em português, utilizar nomes de variáveis em inglês poderia adicionar um esforço cognitivo desnecessário.&lt;/p&gt;

&lt;h2 id=&quot;e-a-minha-opinio&quot;&gt;E a minha opinião?&lt;/h2&gt;

&lt;p&gt;Acredito ter sido capaz de demonstrar que existem boas opiniões nos dois lados desse debate. Mas e aí? Vocês devem estar se perguntando qual a minha opinião, não é? Ok, não vou ficar em cima do muro. Mas antes, acho necessário fazer algumas considerações importantes.&lt;/p&gt;

&lt;h3 id=&quot;o-ingls--a-lngua-franca-da-tecnologia&quot;&gt;O inglês é a língua franca da tecnologia&lt;/h3&gt;

&lt;p&gt;O inglês é a língua franca da tecnologia. E da ciência, das finanças, e de muitas outras coisas. Todo mundo tem o direito de gostar ou não do idioma que quiser, mas é simplesmente contra produtivo querer brigar com um fato da vida que não vai mudar tão cedo. Eu particularmente acho que deveríamos ser gratos que o “idioma obrigatório” é o inglês, e não o russo, árabe, ou mandarim, por exemplo.&lt;/p&gt;

&lt;p&gt;Então, independente do seu posicionamento no debate, aprender inglês é um investimento que vale muito a pena. O que nos leva ao próximo ponto.&lt;/p&gt;

&lt;h3 id=&quot;e-no--to-difcil-de-se-aprender-quanto-parece&quot;&gt;E não é tão difícil de se aprender quanto parece&lt;/h3&gt;

&lt;p&gt;Estou convencido de que uma enorme inteligência não é requisito para aprender inglês. Muito menos pagar cursos caros em escolas renomadas, ou fazer intercâmbio. Então por que há tantas pessoas que querem aprender inglês e &lt;a href=&quot;http://exame.abril.com.br/brasil/noticias/fluencia-do-brasileiro-no-ingles-so-piora-veja-ranking&quot;&gt;tão poucas conseguem&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;Em minha opinião, o primeiro motivo é que a maioria dessas pessoas não &lt;em&gt;querem&lt;/em&gt; realmente. E o segundo…é simplesmente que elas estudam errado, colocando o foco, tempo e energia no lugar onde não deviam.&lt;/p&gt;

&lt;p&gt;Em breve vou fazer um post totalmente dedicado ao tema do aprendizado de inglês, onde vou expandir e explicar melhor o parágrafo anterior.&lt;/p&gt;

&lt;h3 id=&quot;seu-projeto-tem-caractersticas-nicas-que-no-devem-ser-ignoradas&quot;&gt;Seu projeto tem características únicas que não devem ser ignoradas&lt;/h3&gt;

&lt;p&gt;Seu projeto atual provavelmente tem características únicas, que nem eu, nem o Fabio Akita, nem o Tiago Motta, ou qualquer outra pessoa de fora sabe. Não conhecemos o nível de fluência no inglês da sua equipe, nem o domínio da sua aplicação.&lt;/p&gt;

&lt;p&gt;Também desconhecemos o escopo do seu projeto, se todos os colaboradores são brasileiros ou se há pessoas de outros países,os prospectos de venda da empresa para uma companhia multinacional, etc.&lt;/p&gt;

&lt;p&gt;Ou seja: há uma série de fatores que podem e devem ser levadas em conta no momento de se adotar essa ou aquela prática, essa ou aquela metodologia. Nessas horas, você tem que exercitar o senso crítico: mantenha a mente aberta na hora de ler, pesquisar e conhecer opiniões contrárias, mas use seu bom senso e experiência para filtrar o e decidir o que encaixa com a cultura da sua empresa, equipe e projeto.&lt;/p&gt;

&lt;h3 id=&quot;tentar-prever-o-futuro--anti-gil&quot;&gt;Tentar prever o futuro é anti-ágil.&lt;/h3&gt;

&lt;p&gt;Eu costumo chamar isso de síndrome do “vai que um dia”, pois a conversa geralmente começa assim:&lt;/p&gt;

&lt;p&gt;“Vai que um dia o cliente precisa de [insira aqui funcionalidade que o cliente não precisa agora e provavelmente nunca vai precisar]? Vamos fazer!”&lt;/p&gt;

&lt;p&gt;E aí já viu: tabelas inúteis são criadas no banco de dados, classes e mais classes e formulários e telas e muito mais lixo entupindo seu projeto.&lt;/p&gt;

&lt;p&gt;Tentar prever toda e qualquer alteração no projeto é anti-ágil. Equipes ágeis dão pequenos passos, implementando as histórias priorizadas pelo cliente e nada mais. Quando os requisitos mudarem (e vão mudar) nós mudamos junto com eles.&lt;/p&gt;

&lt;p&gt;Entendeu onde eu quero chegar? “Vai que um dia uma empresa internacional resolve comprar nosso sistema? Vamos fazer todo o código e as tabelas em inglês!”&lt;/p&gt;

&lt;h3 id=&quot;em-resumo-bom-senso--a-chave&quot;&gt;Em resumo: bom-senso é a chave&lt;/h3&gt;

&lt;p&gt;Com base em tudo isso aí que você leu, minha opinião atualmente está assim: tentar utilizar o inglês sempre, &lt;strong&gt;exceto quando há ótimas razões para não utilizá-lo.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Projetos open-source? Tudo em inglês, &lt;em&gt;exceto em casos onde há benefícios claros em usar o português&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Em projetos particulares: se a equipe é fraca no inglês &lt;strong&gt;E/OU&lt;/strong&gt; o domínio é muito específico e tem termos e jargões de difícil tradução &lt;strong&gt;E/OU&lt;/strong&gt; há riscos claros de prejuízo na comunicação com o cliente, o português provavelmente é a melhor escolha.&lt;/p&gt;

&lt;p&gt;Se a situação é o contrário do descrito acima, inglês sem dúvida.&lt;/p&gt;

&lt;p&gt;Se desde o começo do projeto existe a certeza que a aplicação será disponibilizada para vários países, vocês vão precisar trabalhar em internacionalização, de tudo: especificações, ajuda, interface gráfica. Nesse caso, também não há motivo para não codificar em inglês.&lt;/p&gt;

&lt;h2 id=&quot;e-voc-o-que-acha&quot;&gt;E você, o que acha?&lt;/h2&gt;

&lt;p&gt;Concorda, discorda, prefere não opinar? Deixe um comentário aí em baixo e vamos continuando a conversa!&lt;/p&gt;

&lt;h2 id=&quot;referncias&quot;&gt;Referências&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://pt.stackoverflow.com/questions/301/devo-escrever-meu-programa-em-ingl%C3%AAs-ou-portugu%C3%AAs&quot;&gt;http://pt.stackoverflow.com/questions/301/devo-escrever-meu-programa-em-ingl%C3%AAs-ou-portugu%C3%AAs&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://programandosemcafeina.blogspot.com.br/2009/03/nomes-de-metodos-e-variaveis-devem-ser.html&quot;&gt;http://programandosemcafeina.blogspot.com.br/2009/03/nomes-de-metodos-e-variaveis-devem-ser.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://nsigustavo.blogspot.com.br/2009/09/que-idioma-devemos-utilizar-em-nosso.html&quot;&gt;http://nsigustavo.blogspot.com.br/2009/09/que-idioma-devemos-utilizar-em-nosso.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blogdofernandocorreia.wordpress.com/2011/09/21/que-lingua-usar-para-nomes-do-dominio-de-negocio/&quot;&gt;https://blogdofernandocorreia.wordpress.com/2011/09/21/que-lingua-usar-para-nomes-do-dominio-de-negocio/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.dev.mayogax.com/2014/02/a-polemica-questao-do-stack-overflow-em-portugues/&quot;&gt;http://www.dev.mayogax.com/2014/02/a-polemica-questao-do-stack-overflow-em-portugues/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://nomedojogo.com/2009/02/13/rails-way-3-nomes-de-metodos-e-variaveis-devem-ser-obvios/&quot;&gt;http://nomedojogo.com/2009/02/13/rails-way-3-nomes-de-metodos-e-variaveis-devem-ser-obvios/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ventron.com.br/programar-em-portugues-ou-ingles/&quot;&gt;http://www.ventron.com.br/programar-em-portugues-ou-ingles/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 29 Mar 2016 00:00:00 -0300</pubDate>
        <link>http://carlosschults.net/pt/programar-portugues-ou-ingles/</link>
        <guid isPermaLink="true">http://carlosschults.net/pt/programar-portugues-ou-ingles/</guid>
        
        <category>boas práticas</category>
        
        <category>inglês</category>
        
        
      </item>
    
  </channel>
</rss>
